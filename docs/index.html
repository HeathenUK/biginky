<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BigInky Remote Control</title>
<style>
body{font-family:Arial,sans-serif;max-width:1200px;margin:0 auto;padding:20px;background:#1a1a1a;color:#e0e0e0;}
h1{color:#e0e0e0;border-bottom:2px solid #4CAF50;padding-bottom:10px;}
.section{background:#2a2a2a;padding:20px;margin:20px 0;border-radius:8px;box-shadow:0 2px 4px rgba(0,0,0,0.3);}
h2{color:#4CAF50;margin-top:0;}
label{display:block;margin:10px 0 5px 0;font-weight:bold;color:#e0e0e0;}
textarea{width:100%;min-height:100px;font-family:monospace;padding:10px;border:1px solid #444;border-radius:4px;box-sizing:border-box;background:#1a1a1a;color:#e0e0e0;}
select{width:100%;padding:8px;border:1px solid #444;border-radius:4px;box-sizing:border-box;background:#1a1a1a;color:#e0e0e0;}
input[type="text"]{width:100%;padding:8px;border:1px solid #444;border-radius:4px;box-sizing:border-box;background:#1a1a1a;color:#e0e0e0;}
button{background:#4CAF50;color:white;border:none;padding:10px 20px;border-radius:4px;cursor:pointer;font-size:16px;margin:5px;min-height:44px;touch-action:manipulation;-webkit-tap-highlight-color:rgba(76,175,80,0.3);}
button:hover{background:#45a049;}
button:disabled{background:#666;cursor:not-allowed;opacity:0.6;}
.status{color:#4CAF50;margin:10px 0;font-weight:bold;}
.error{color:#f44336;}
.info{color:#2196F3;margin:10px 0;padding:10px;background:#1a1a1a;border-radius:4px;border-left:3px solid #2196F3;}
.connection-status{display:inline-flex;align-items:center;gap:8px;padding:5px 10px;border-radius:4px;font-weight:bold;margin-left:10px;}
.connection-status::before{font-size:16px;}
.connected{background:#4CAF50;color:white;}
.connected::before{content:'‚úì';}
.disconnected{background:#f44336;color:white;}
.disconnected::before{content:'‚úó';}
.connecting{background:#ff9800;color:white;}
.connecting::before{content:'‚ü≥';animation:spin 1s linear infinite;}
.reconnecting{background:#ff9800;color:white;}
.reconnecting::before{content:'‚ü≥';animation:spin 1s linear infinite;}
.status-timestamp{font-size:11px;opacity:0.7;margin-left:10px;font-weight:normal;}
.flex-row{display:flex;flex-wrap:wrap;gap:15px;align-items:flex-end;margin-top:15px;}
.flex-item{flex:1;min-width:150px;}
button.flex-shrink{flex-shrink:0;margin-top:0;}
.tool-btn{background:#333;border:2px solid #555;color:#e0e0e0;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;}
.tool-btn:hover{background:#444;border-color:#666;}
.tool-btn.active{background:#4CAF50;border-color:#45a049;color:white;}
h2{cursor:pointer;user-select:none;position:relative;padding-right:20px;}
h2::after{content:'‚ñº';position:absolute;right:0;font-size:14px;opacity:0.7;transition:transform 0.2s;}
h2.collapsed::after{transform:rotate(-90deg);}
.section-content{overflow:hidden;transition:max-height 0.3s ease-out;}
.section-content.collapsed{display:none;}
canvas{border:2px solid #666;cursor:crosshair;background:#fff;touch-action:none;margin-top:10px;display:block;max-width:100%;height:auto;}
.busy-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);display:none;align-items:center;justify-content:center;z-index:10000;flex-direction:column;}
.busy-overlay.active{display:flex;}
.busy-overlay .message{color:#fff;font-size:18px;margin-top:20px;text-align:center;}
.spinner{border:4px solid rgba(255,255,255,0.3);border-top:4px solid #4CAF50;border-radius:50%;width:50px;height:50px;animation:spin 1s linear infinite;}
@keyframes spin{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}
/* Responsive design for mobile devices */
@media (max-width:768px){
body{padding:10px;}
.section{padding:15px;margin:15px 0;}
h1{font-size:24px;}
h2{font-size:20px;}
button{font-size:14px;padding:8px 16px;margin:3px;}
.flex-row{gap:10px;}
.flex-item{min-width:100%;}
/* Make tables horizontally scrollable on mobile */
.table-wrapper{overflow-x:auto;-webkit-overflow-scrolling:touch;}
table{min-width:600px;font-size:14px;}
table th,table td{padding:8px;font-size:13px;}
/* Responsive thumbnails - scale down on mobile */
.media-thumbnail{max-width:150px!important;max-height:112px!important;width:auto;height:auto;}
/* Stack form elements vertically on mobile */
.flex-row{flex-direction:column;}
.flex-item{width:100%;}
button.flex-shrink{width:100%;margin-top:10px;}
}
@media (max-width:480px){
body{padding:8px;}
.section{padding:12px;margin:12px 0;}
h1{font-size:20px;}
h2{font-size:18px;}
button{font-size:13px;padding:8px 12px;}
table{min-width:500px;font-size:12px;}
table th,table td{padding:6px;font-size:12px;}
.media-thumbnail{max-width:120px!important;max-height:90px!important;}
.busy-overlay .message{font-size:16px;padding:0 20px;}
}
</style>
<script src="https://cdn.jsdelivr.net/gh/eclipse/paho.mqtt.javascript@master/src/paho-mqtt.js" onerror="loadPahoFallback()"></script>
<script>
let pahoLibraryLoaded = false;

function checkPahoLoaded() {
    // Paho library exposes Paho.Client and Paho.Message, not Paho.MQTT.Client
    if (typeof Paho !== 'undefined' && typeof Paho.Client !== 'undefined') {
        pahoLibraryLoaded = true;
        console.log('Paho MQTT library loaded successfully');
        return true;
    }
    return false;
}

function loadPahoFallback() {
    console.log('Paho MQTT library failed to load from jsDelivr, trying fallback...');
    const script = document.createElement('script');
    script.src = 'https://unpkg.com/paho-mqtt@1.1.0/paho-mqtt.js';
    script.onload = function() {
        if (checkPahoLoaded()) {
            console.log('Paho MQTT library loaded from fallback (unpkg)');
        } else {
            console.error('Library loaded but structure incorrect');
        }
    };
    script.onerror = function() {
        console.error('Failed to load Paho MQTT from all sources');
        document.getElementById('connectionStatusMsg').innerHTML = '<div class="error">Error: Could not load MQTT library. Please check your internet connection or try refreshing the page.</div>';
    };
    document.head.appendChild(script);
}

// Verify Paho library loaded after page load
window.addEventListener('load', function() {
    setTimeout(function() {
        if (!checkPahoLoaded()) {
            loadPahoFallback();
        }
        // Load password from sessionStorage (after functions are defined)
        if (typeof loadPassword === 'function') {
            loadPassword();  // loadPassword is async but we don't await it here
        } else {
            // Functions not loaded yet, wait a bit
            setTimeout(function() {
                if (typeof loadPassword === 'function') {
                    loadPassword();
                }
            }, 100);
        }
    }, 100);
});
</script>
</head>
<body>
<div id="busyOverlay" class="busy-overlay">
<div class="spinner"></div>
<div class="message">Processing command... Please wait for device to respond.</div>
</div>
<h1>BigInky Remote Control</h1>
<div class="section">
<h2 onclick="toggleSection(this)">Authentication (Required)</h2>
<div class="section-content" id="section-auth">
<p style="color:#888;font-size:14px;margin-bottom:15px;"><strong>Password required.</strong> Enter the device password (set via local WiFi UI) to enable HMAC authentication. All functionality is disabled until a password is set.</p>
<div class="flex-row" style="align-items:center;gap:10px;">
<div style="flex:0 0 auto;white-space:nowrap;">
<label style="display:inline;margin:0;margin-right:8px;">Web UI Password:</label>
</div>
<div style="flex:1 1 auto;min-width:200px;">
<input type="password" id="webUIPassword" placeholder="Enter password (min 8 characters)..." style="width:100%;padding:8px;border:1px solid #444;border-radius:4px;box-sizing:border-box;background:#1a1a1a;color:#e0e0e0;font-family:monospace;height:38px;">
</div>
<div style="flex:0 0 auto;display:flex;gap:10px;">
<button onclick="savePassword()" style="height:38px;padding:8px 16px;">Save Password</button>
<button onclick="clearPassword()" style="height:38px;padding:8px 16px;background:#f44336;">Clear Password</button>
</div>
</div>
<div id="passwordStatus" style="margin-top:10px;"></div>
</div>
</div>
<div class="section">
<h2 onclick="toggleSection(this)">Connection</h2>
<div class="section-content" id="section-connection">
<div style="text-align:center;">
<button onclick="connectMQTT()" id="connectBtn">Connect</button>
<button onclick="disconnectMQTT()" id="disconnectBtn" disabled>Disconnect</button>
<div style="margin-top:10px;">
<span id="connectionStatus" class="connection-status disconnected">Disconnected</span>
</div>
<div id="connectionStatusMsg" style="margin-top:10px;"></div>
</div>
</div>
<div class="section">
<h2 onclick="toggleSection(this)">Device Status</h2>
<div class="section-content" id="section-status">
<div id="deviceStatus" style="font-family:monospace;font-size:12px;color:#e0e0e0;">
<p>Not connected - status appears when connected</p>
</div>
</div>
</div>
<div class="section">
<h2 onclick="toggleSection(this)">Display Preview</h2>
<div class="section-content" id="section-preview">
<p>Latest display content (updated on refresh):</p>
<div id="thumbnailContainer" style="text-align:center;margin:20px 0;">
<canvas id="thumbnailCanvas" width="400" height="300" style="border:2px solid #666;background:#fff;max-width:100%;height:auto;display:none;"></canvas>
<p id="thumbnailStatus" style="color:#888;">No preview available yet</p>
</div>
</div>
</div>
</div>
<div class="section">
<h2 onclick="toggleSection(this)">Media Mappings</h2>
<div class="section-content" id="section-media">
<p>Available media files from media.txt:</p>
<div id="mediaMappingsStatus" style="color:#888;margin-bottom:10px;">Not loaded - appears when connected</div>
<div class="table-wrapper">
<div id="mediaMappingsTable">
<!-- Table will be populated here -->
</div>
</div>
</div>
</div>
<div class="section">
<h2 onclick="toggleSection(this)">Text Display</h2>
<div class="section-content" id="section-text">
<p>Enter text to display. Select text, background, and outline colours.</p>
<label>Text:</label>
<textarea id="textInput" placeholder="Enter text to display..."></textarea>
<div class="flex-row">
<div class="flex-item">
<label>Text Colour:</label>
<select id="textColor">
<option value="black" selected>Black</option>
<option value="yellow">Yellow</option>
<option value="red">Red</option>
<option value="blue">Blue</option>
<option value="green">Green</option>
<option value="multi">Multi (Random Colours)</option>
<option value="white">White</option>
</select>
</div>
<div class="flex-item">
<label>Background Colour:</label>
<select id="textBackgroundColor">
<option value="black">Black</option>
<option value="yellow">Yellow</option>
<option value="red">Red</option>
<option value="blue">Blue</option>
<option value="green">Green</option>
<option value="white" selected>White</option>
</select>
</div>
<div class="flex-item">
<label>Outline Colour:</label>
<select id="textOutlineColor">
<option value="black" selected>Black</option>
<option value="yellow">Yellow</option>
<option value="red">Red</option>
<option value="blue">Blue</option>
<option value="green">Green</option>
<option value="white">White</option>
</select>
</div>
<button onclick="sendTextDisplay()" class="flex-shrink" id="textDisplayBtn" disabled>Display Text</button>
</div>
<div id="textStatus"></div>
</div>
<div class="section">
<h2 onclick="toggleSection(this)">Drawing Canvas</h2>
<div class="section-content" id="section-canvas">
<p>Draw on the canvas (1600x1200) - matches the display panel size. Images can be loaded and will be automatically posterized to match e-ink colors.</p>
<div style="margin-bottom:15px;">
<label style="display:block;margin-bottom:8px;">Tool:</label>
<div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:15px;">
<button onclick="setTool('brush')" id="tool-brush" class="tool-btn active" title="Brush" style="width:44px;height:44px;padding:8px;font-size:20px;">üñåÔ∏è</button>
<button onclick="setTool('text')" id="tool-text" class="tool-btn" title="Text" style="width:44px;height:44px;padding:8px;font-size:20px;">T</button>
<button onclick="setTool('fill')" id="tool-fill" class="tool-btn" title="Fill" style="width:44px;height:44px;padding:8px;font-size:20px;">ü™£</button>
<button onclick="setTool('rectangle')" id="tool-rectangle" class="tool-btn" title="Rectangle" style="width:44px;height:44px;padding:8px;font-size:20px;">‚ñ≠</button>
<button onclick="setTool('circle')" id="tool-circle" class="tool-btn" title="Circle" style="width:44px;height:44px;padding:8px;font-size:20px;">‚óã</button>
<button onclick="setTool('line')" id="tool-line" class="tool-btn" title="Line" style="width:44px;height:44px;padding:8px;font-size:20px;">/</button>
<button onclick="setTool('eraser')" id="tool-eraser" class="tool-btn" title="Eraser" style="width:44px;height:44px;padding:8px;font-size:20px;">üßπ</button>
</div>
</div>
<div class="flex-row" style="margin-bottom:15px;">
<div class="flex-item" style="min-width:120px;">
<label id="colorLabel">Colour:</label>
<select id="drawColor" style="width:100%;">
<option value="0" selected>Black</option>
<option value="2">Yellow</option>
<option value="3">Red</option>
<option value="5">Blue</option>
<option value="6">Green</option>
<option value="1">White</option>
</select>
</div>
<div class="flex-item" id="fillColorContainer" style="min-width:120px;display:none;">
<label>Fill Colour:</label>
<select id="fillColor" style="width:100%;">
<option value="1" selected>White</option>
<option value="0">Black</option>
<option value="2">Yellow</option>
<option value="3">Red</option>
<option value="5">Blue</option>
<option value="6">Green</option>
</select>
</div>
<div class="flex-item" id="outlineColorContainer" style="min-width:120px;display:none;">
<label>Outline Colour:</label>
<select id="outlineColor" style="width:100%;">
<option value="0" selected>Black</option>
<option value="2">Yellow</option>
<option value="3">Red</option>
<option value="5">Blue</option>
<option value="6">Green</option>
<option value="1">White</option>
</select>
</div>
<div class="flex-item" id="textToolOptions" style="min-width:150px;display:none;">
<label>Font Size:</label>
<select id="textFontSize" style="width:100%;">
<option value="12">12px</option>
<option value="16">16px</option>
<option value="20">20px</option>
<option value="24" selected>24px</option>
<option value="32">32px</option>
<option value="48">48px</option>
<option value="64">64px</option>
<option value="96">96px</option>
</select>
</div>
<div class="flex-item" id="textInputContainer" style="min-width:200px;display:none;">
<label>Text:</label>
<input type="text" id="canvasTextInput" placeholder="Enter text..." style="width:100%;padding:6px;border:1px solid #444;border-radius:4px;box-sizing:border-box;background:#1a1a1a;color:#e0e0e0;">
</div>
</div>
<div style="margin-bottom:10px;">
<button onclick="clearCanvas()">Clear Canvas</button>
<button onclick="undoCanvas()" id="undoBtn" disabled>Undo</button>
<button onclick="loadImageToCanvas()" id="loadImageBtn">Load Image</button>
<input type="file" id="imageFileInput" accept="image/*" style="display:none;" onchange="handleImageFileSelect(event)">
<button onclick="sendCanvasToDisplay()" id="canvasDisplayBtn" disabled>Display on Panel</button>
</div>
<canvas id="drawCanvas" width="1600" height="1200" style="max-width:100%;height:auto;"></canvas>
<div id="canvasStatus"></div>
</div>
</div>
<div class="section">
<h2 onclick="toggleSection(this)">Other Commands</h2>
<div class="section-content" id="section-commands">
<button onclick="sendCommand('clear')" id="clearBtn" disabled>Clear Display</button>
<button onclick="sendCommand('next')" id="nextBtn" disabled>Next Media Item</button>
<div id="commandStatus"></div>
</div>
</div>
<div class="section">
<h2 onclick="toggleSection(this)">Command Log</h2>
<div class="section-content" id="section-log">
<div id="commandLog" style="max-height:300px;overflow-y:auto;background:#1a1a1a;padding:10px;border:1px solid #444;border-radius:4px;font-family:monospace;font-size:12px;white-space:pre-wrap;word-wrap:break-word;color:#e0e0e0;"></div>
</div>
</div>
<script>
const MQTT_BROKER = 'mqtt.flespi.io';
const MQTT_PORT = 443;
const MQTT_TOPIC = 'devices/web-ui/cmd';
const MQTT_TOPIC_STATUS = 'devices/web-ui/status';
const MQTT_TOPIC_THUMB = 'devices/web-ui/thumb';
const MQTT_TOPIC_MEDIA = 'devices/web-ui/media';
// Embedded restricted token for web UI (publish-only to devices/web-ui/cmd)
// TODO: Replace with your actual restricted Flespi.io token
const EMBEDDED_TOKEN = 'WdTjkCQjNXodmMWLSDWhAvrE6dDmcoQY1V47HSd3M7mb9P4HI3Ph8nTnA18MioBn';
let mqttClient = null;
let isConnected = false;
let webUIPassword = null;  // Stored password for HMAC computation
let sessionEncryptionKey = null;  // Session key for encrypting stored password
let isBusy = false;  // Busy state for command processing
let busyTimeoutId = null;  // Timeout ID for busy state
let autoReconnectEnabled = true;
let reconnectAttempts = 0;
let reconnectTimeoutId = null;
const MAX_RECONNECT_ATTEMPTS = 10;
const INITIAL_RECONNECT_DELAY = 1000; // 1 second

// Initialize session encryption key (derived from session ID)
async function initSessionEncryptionKey() {
    if (sessionEncryptionKey) return sessionEncryptionKey;
    
    // Generate a session-specific key from a random value stored in sessionStorage
    let sessionId = sessionStorage.getItem('biginky_session_id');
    if (!sessionId) {
        // Generate new session ID
        sessionId = Array.from(crypto.getRandomValues(new Uint8Array(32)))
            .map(b => b.toString(16).padStart(2, '0')).join('');
        sessionStorage.setItem('biginky_session_id', sessionId);
    }
    
    // Derive encryption key from session ID using PBKDF2
    const encoder = new TextEncoder();
    const sessionIdData = encoder.encode(sessionId);
    const salt = encoder.encode('biginky_session_salt_v1');
    
    const keyMaterial = await crypto.subtle.importKey(
        'raw',
        sessionIdData,
        { name: 'PBKDF2' },
        false,
        ['deriveBits', 'deriveKey']
    );
    
    sessionEncryptionKey = await crypto.subtle.deriveKey(
        {
            name: 'PBKDF2',
            salt: salt,
            iterations: 100000,
            hash: 'SHA-256'
        },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt', 'decrypt']
    );
    
    return sessionEncryptionKey;
}

// Encrypt password for storage
async function encryptPasswordForStorage(password) {
    const key = await initSessionEncryptionKey();
    const encoder = new TextEncoder();
    const passwordData = encoder.encode(password);
    
    // Generate random IV for GCM
    const iv = crypto.getRandomValues(new Uint8Array(12));
    
    // Encrypt
    const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv: iv },
        key,
        passwordData
    );
    
    // Combine IV + ciphertext and base64 encode
    const combined = new Uint8Array(iv.length + encrypted.byteLength);
    combined.set(iv, 0);
    combined.set(new Uint8Array(encrypted), iv.length);
    
    // Convert to base64 (avoid spread operator for large arrays)
    let binaryString = '';
    for (let i = 0; i < combined.length; i++) {
        binaryString += String.fromCharCode(combined[i]);
    }
    return btoa(binaryString);
}

// Decrypt password from storage
async function decryptPasswordFromStorage(encryptedBase64) {
    try {
        const key = await initSessionEncryptionKey();
        
        // Decode base64
        const combined = Uint8Array.from(atob(encryptedBase64), c => c.charCodeAt(0));
        
        // Extract IV and ciphertext
        const iv = combined.slice(0, 12);
        const ciphertext = combined.slice(12);
        
        // Decrypt
        const decrypted = await crypto.subtle.decrypt(
            { name: 'AES-GCM', iv: iv },
            key,
            ciphertext
        );
        
        // Convert to string
        const decoder = new TextDecoder();
        return decoder.decode(decrypted);
    } catch (e) {
        console.error('Failed to decrypt password:', e);
        return null;
    }
}

// Load password from sessionStorage on page load
async function loadPassword() {
    const stored = sessionStorage.getItem('biginky_webui_password');
    if (stored) {
        try {
            // Try to decrypt (new encrypted format)
            webUIPassword = await decryptPasswordFromStorage(stored);
            if (!webUIPassword) {
                // If decryption fails, try legacy base64 format (for migration)
                try {
                    webUIPassword = atob(stored);
                } catch (e) {
                    console.error('Failed to load password (both encrypted and legacy formats failed):', e);
                    webUIPassword = null;
                }
            }
            if (webUIPassword) {
                document.getElementById('webUIPassword').value = webUIPassword;
            }
        } catch (e) {
            console.error('Failed to load password:', e);
            webUIPassword = null;
        }
    } else {
        webUIPassword = null;
    }
    updatePasswordStatus();
}

// Encrypt a message using AES-256-CBC
async function encryptMessage(plaintext) {
    if (!webUIPassword) {
        console.error('No password configured for encryption');
        return null;
    }
    
    try {
        // Derive encryption key from password
        const encryptionKey = await deriveEncryptionKey(webUIPassword);
        
        // Import key for AES-CBC
        const key = await crypto.subtle.importKey(
            'raw',
            encryptionKey,
            { name: 'AES-CBC' },
            false,
            ['encrypt']
        );
        
        // Generate random IV (16 bytes)
        const iv = crypto.getRandomValues(new Uint8Array(16));
        
        // Encrypt
        const encoder = new TextEncoder();
        const plaintextData = encoder.encode(plaintext);
        const ciphertext = await crypto.subtle.encrypt(
            { name: 'AES-CBC', iv: iv },
            key,
            plaintextData
        );
        
        // Combine IV + ciphertext and base64 encode
        const combined = new Uint8Array(16 + ciphertext.byteLength);
        combined.set(iv, 0);
        combined.set(new Uint8Array(ciphertext), 16);
        
        // Base64 encode
        const binaryString = String.fromCharCode.apply(null, combined);
        const base64 = btoa(binaryString);
        
        return base64;
    } catch (e) {
        console.error('Encryption error:', e);
        return null;
    }
}

// Decrypt a message using AES-256-CBC
// Accepts either: (ciphertextBase64) for legacy format with IV prepended
//                 or (payloadBase64, ivBase64) for new format with separate IV
async function decryptMessage(payloadBase64, ivBase64) {
    if (!webUIPassword) {
        console.error('No password configured for decryption');
        return null;
    }
    
    try {
        let iv, ciphertext;
        
        // Diagnostic: Log payload base64 length
        console.log('decryptMessage: payloadBase64 length:', payloadBase64 ? payloadBase64.length : 0);
        console.log('decryptMessage: ivBase64 length:', ivBase64 ? ivBase64.length : 0);
        
        if (ivBase64) {
            // New format: IV and payload are separate
            const ivBinaryString = atob(ivBase64);
            iv = new Uint8Array(ivBinaryString.length);
            for (let i = 0; i < ivBinaryString.length; i++) {
                iv[i] = ivBinaryString.charCodeAt(i);
            }
            
            const payloadBinaryString = atob(payloadBase64);
            ciphertext = new Uint8Array(payloadBinaryString.length);
            for (let i = 0; i < payloadBinaryString.length; i++) {
                ciphertext[i] = payloadBinaryString.charCodeAt(i);
            }
        } else {
            // Legacy format: IV is prepended to ciphertext
            const binaryString = atob(payloadBase64);
            const combined = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                combined[i] = binaryString.charCodeAt(i);
            }
            
            // Extract IV (first 16 bytes) and ciphertext
            iv = combined.slice(0, 16);
            ciphertext = combined.slice(16);
        }
        
        // Diagnostic: Log decoded lengths
        console.log('decryptMessage: IV length (decoded):', iv.length);
        console.log('decryptMessage: ciphertext length (decoded):', ciphertext.length);
        console.log('decryptMessage: ciphertext length % 16:', ciphertext.length % 16);
        
        // Validate IV length
        if (iv.length !== 16) {
            console.error('Invalid IV length:', iv.length, '(expected 16)');
            return null;
        }
        
        // Validate ciphertext is not empty
        if (ciphertext.length === 0) {
            console.error('Ciphertext is empty');
            return null;
        }
        
        // Validate ciphertext length is multiple of 16 (AES block size)
        if (ciphertext.length % 16 !== 0) {
            console.error('Invalid ciphertext length (not multiple of 16):', ciphertext.length, 'remainder:', ciphertext.length % 16);
            console.error('This will cause Web Crypto API to fail. Ciphertext may be truncated or corrupted.');
            return null;
        }
        
        // Derive encryption key from password
        const encryptionKey = await deriveEncryptionKey(webUIPassword);
        
        // Import key for AES-CBC
        const key = await crypto.subtle.importKey(
            'raw',
            encryptionKey,
            { name: 'AES-CBC' },
            false,
            ['decrypt']
        );
        
        // Decrypt
        let plaintext;
        try {
            console.log('decryptMessage: Attempting decryption with ciphertext length:', ciphertext.length, 'bytes');
            plaintext = await crypto.subtle.decrypt(
                { name: 'AES-CBC', iv: iv },
                key,
                ciphertext
            );
            console.log('decryptMessage: Decryption successful, plaintext length:', plaintext.byteLength, 'bytes');
        } catch (decryptError) {
            console.error('crypto.subtle.decrypt failed:', decryptError);
            console.error('Decryption failure details:');
            console.error('  - IV length:', iv.length);
            console.error('  - Ciphertext length:', ciphertext.length);
            console.error('  - Ciphertext length % 16:', ciphertext.length % 16);
            console.error('  - Error name:', decryptError.name);
            console.error('  - Error message:', decryptError.message);
            // This usually means the key is wrong or the ciphertext is corrupted
            return null;
        }
        
        // Remove PKCS7 padding from ArrayBuffer BEFORE converting to string
        // Padding bytes might not be valid UTF-8, so we must remove them first
        const plaintextArray = new Uint8Array(plaintext);
        if (plaintextArray.length === 0) {
            console.error('Decrypted plaintext is empty');
            return null;
        }
        
        // Debug: log first few bytes of decrypted data
        const debugBytes = Array.from(plaintextArray.slice(0, Math.min(20, plaintextArray.length)));
        console.log('Decrypted bytes (first 20):', debugBytes.map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
        
        // Get padding value (last byte)
        const padValue = plaintextArray[plaintextArray.length - 1];
        
        // Try to remove padding
        let unpaddedArray;
        let paddingValid = false;
        
        // Validate padding (must be between 1 and 16)
        if (padValue >= 1 && padValue <= 16) {
            // Verify all padding bytes are the same
            const paddingStart = plaintextArray.length - padValue;
            if (paddingStart >= 0) {
                let allSame = true;
                for (let i = paddingStart; i < plaintextArray.length; i++) {
                    if (plaintextArray[i] !== padValue) {
                        allSame = false;
                        break;
                    }
                }
                if (allSame) {
                    // Valid padding - remove it
                    unpaddedArray = plaintextArray.slice(0, paddingStart);
                    paddingValid = true;
                }
            }
        }
        
        // If padding validation failed, try fallback: check if data looks like valid JSON
        if (!paddingValid) {
            // Check if decrypted data starts with '{' and ends with '}'
            const firstByte = plaintextArray[0];
            const lastByte = plaintextArray[plaintextArray.length - 1];
            
            if (firstByte === 0x7b && lastByte === 0x7d) {  // '{' and '}'
                // Looks like JSON - try to find actual padding by checking from the end
                // Try common padding values (1-16) and see if removing that many bytes gives valid JSON
                let foundValidPadding = false;
                for (let tryPad = 1; tryPad <= 16 && !foundValidPadding; tryPad++) {
                    const tryStart = plaintextArray.length - tryPad;
                    if (tryStart > 0) {
                        const tryUnpadded = plaintextArray.slice(0, tryStart);
                        // Check if all padding bytes are the same
                        let allSame = true;
                        for (let i = tryStart; i < plaintextArray.length; i++) {
                            if (plaintextArray[i] !== tryPad) {
                                allSame = false;
                                break;
                            }
                        }
                        if (allSame) {
                            // Try to parse as JSON
                            try {
                                const decoder = new TextDecoder('utf-8', { fatal: false });
                                const jsonStr = decoder.decode(tryUnpadded);
                                JSON.parse(jsonStr);
                                // Valid JSON! Use this padding
                                unpaddedArray = tryUnpadded;
                                paddingValid = true;
                                foundValidPadding = true;
                                console.log('Padding validation fallback succeeded with padding value:', tryPad);
                            } catch (e) {
                                // Not valid JSON, continue trying
                            }
                        }
                    }
                }
            }
            
            // If still no valid padding found, try to decode anyway
            if (!paddingValid) {
                // Last resort: try to decode as-is and check if it's valid JSON
                try {
                    const decoder = new TextDecoder('utf-8', { fatal: false });
                    const jsonStr = decoder.decode(plaintextArray);
                    if (jsonStr.trim().startsWith('{') && jsonStr.trim().endsWith('}')) {
                        // Looks like JSON - try parsing
                        JSON.parse(jsonStr);
                        // If we get here, it's valid JSON - use it as-is
                        // Web Crypto API already removed padding, so this is expected
                        unpaddedArray = plaintextArray;
                        // Don't log error - this is normal when Web Crypto API removes padding
                    } else {
                        // Only log error if JSON parsing also fails
                        console.error('Invalid padding value:', padValue, '(expected 1-16)');
                        console.error('Plaintext length:', plaintextArray.length);
                        console.error('Last 16 bytes:', Array.from(plaintextArray.slice(-16)).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                        console.error('Decryption returned empty result - data is not valid JSON');
                        return null;
                    }
                } catch (e) {
                    // Only log error if JSON parsing fails
                    console.error('Invalid padding value:', padValue, '(expected 1-16)');
                    console.error('Plaintext length:', plaintextArray.length);
                    console.error('Last 16 bytes:', Array.from(plaintextArray.slice(-16)).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                    console.error('Decryption returned empty result - JSON parsing failed:', e);
                    return null;
                }
            }
        }
        
        // Convert to string
        const decoder = new TextDecoder('utf-8', { fatal: false });
        const decoded = decoder.decode(unpaddedArray);
        
        return decoded;
    } catch (e) {
        console.error('Decryption error:', e);
        return null;
    }
}

// Verify password by attempting to decrypt the retained status message
async function verifyPasswordByDecryption(password) {
    // Try to get the retained status message from MQTT
    // If we're connected, we can request it; otherwise we'll need to connect temporarily
    return new Promise(async (resolve) => {
        if (!mqttClient || !isConnected) {
            // Not connected - we can't verify yet, but we'll allow saving
            // The password will be verified when we connect and receive the first status message
            console.log('Not connected to MQTT - password will be verified on first status message');
            resolve(true);  // Allow saving, verify later
            return;
        }
        
        // We're connected - try to get retained status message
        // The status message should already be in the retained topic
        // We can subscribe and wait for it, or check if we already have it
        // For now, we'll just allow saving and verify on the next status message
        console.log('Connected - password will be verified on next status message');
        resolve(true);  // Allow saving, verify on next message
    });
}

// Save password to localStorage and verify it by decrypting status message
async function savePassword() {
    const password = document.getElementById('webUIPassword').value.trim();
    const passwordStatusEl = document.getElementById('passwordStatus');
    
    if (password.length === 0) {
        passwordStatusEl.innerHTML = '<div class="error" style="margin-top:10px;">Error: Password cannot be empty</div>';
        updatePasswordStatus();
        return;
    }
    if (password.length < 8) {
        passwordStatusEl.innerHTML = '<div class="error" style="margin-top:10px;">Error: Password must be at least 8 characters</div>';
        updatePasswordStatus();
        return;
    }
    
    // Show verifying message
    passwordStatusEl.innerHTML = '<div class="info" style="margin-top:10px;">Verifying password by decrypting status message...</div>';
    
    // Temporarily set password to test decryption
    const oldPassword = webUIPassword;
    webUIPassword = password;
    
    // If connected, try to verify by decrypting a status message
    // We'll subscribe to status topic and wait for retained message
    let verificationSuccess = false;
    
    if (mqttClient && isConnected) {
        // Create a one-time message handler to verify password
        const verifyHandler = async function(message) {
            if (message.destinationName === MQTT_TOPIC_STATUS) {
                try {
                    const payload = JSON.parse(message.payloadString);
                    
                    // Check if message is encrypted
                    if (payload.encrypted && payload.payload) {
                        // Try to decrypt
                        const decrypted = await decryptMessage(payload.payload);
                        if (decrypted) {
                            // Try to parse as JSON to verify it's valid
                            const status = JSON.parse(decrypted);
                            if (status.timestamp || status.current_time) {
                                // Valid decrypted status - password is correct!
                                verificationSuccess = true;
                                mqttClient.unsubscribe(MQTT_TOPIC_STATUS);
                                mqttClient.onMessageArrived = originalHandler;
                                
                                // Save password
                                try {
                                    localStorage.setItem('biginky_webui_password', btoa(password));
                                    passwordStatusEl.innerHTML = '<div class="status" style="margin-top:10px;">‚úì Password verified and saved successfully!</div>';
                                    updatePasswordStatus();
                                } catch (e) {
                                    passwordStatusEl.innerHTML = '<div class="error" style="margin-top:10px;">Error: Failed to save password: ' + e.message + '</div>';
                                    webUIPassword = oldPassword;
                                    updatePasswordStatus();
                                }
                                return;
                            }
                        }
                    } else if (payload.hmac) {
                        // Unencrypted but has HMAC - password might still be correct
                        // For now, allow it (backward compatibility)
                        verificationSuccess = true;
                        mqttClient.unsubscribe(MQTT_TOPIC_STATUS);
                        mqttClient.onMessageArrived = originalHandler;
                        
                        try {
                            localStorage.setItem('biginky_webui_password', btoa(password));
                            passwordStatusEl.innerHTML = '<div class="status" style="margin-top:10px;">‚úì Password saved (unencrypted message received - will verify on encrypted message)</div>';
                            updatePasswordStatus();
                        } catch (e) {
                            passwordStatusEl.innerHTML = '<div class="error" style="margin-top:10px;">Error: Failed to save password: ' + e.message + '</div>';
                            webUIPassword = oldPassword;
                            updatePasswordStatus();
                        }
                        return;
                    }
                } catch (e) {
                    console.error('Failed to verify password:', e);
                }
                
                // Verification failed
                mqttClient.unsubscribe(MQTT_TOPIC_STATUS);
                mqttClient.onMessageArrived = originalHandler;
                webUIPassword = oldPassword;
                passwordStatusEl.innerHTML = '<div class="error" style="margin-top:10px;">‚úó Password verification failed: Could not decrypt status message. Please check your password.</div>';
                updatePasswordStatus();
            }
        };
        
        // Save original handler and set verification handler
        const originalHandler = mqttClient.onMessageArrived;
        mqttClient.onMessageArrived = verifyHandler;
        
        // Subscribe to status topic to get retained message
        mqttClient.subscribe(MQTT_TOPIC_STATUS, { qos: 1 });
        
        // Timeout after 5 seconds
        setTimeout(() => {
            if (!verificationSuccess) {
                mqttClient.unsubscribe(MQTT_TOPIC_STATUS);
                mqttClient.onMessageArrived = originalHandler;
                webUIPassword = oldPassword;
                passwordStatusEl.innerHTML = '<div class="error" style="margin-top:10px;">‚úó Password verification timeout: No status message received. Password saved but not verified. Will verify on next status message.</div>';
                // Still save the password
                try {
                    localStorage.setItem('biginky_webui_password', btoa(password));
                    updatePasswordStatus();
                } catch (e) {
                    console.error('Failed to save password:', e);
                }
            }
        }, 5000);
    } else {
        // Not connected - just save password, verify later
        try {
            localStorage.setItem('biginky_webui_password', btoa(password));
            webUIPassword = password;
            passwordStatusEl.innerHTML = '<div class="info" style="margin-top:10px;">Password saved. Will verify when connected to MQTT and status message is received.</div>';
            updatePasswordStatus();
        } catch (e) {
            console.error('Failed to save password:', e);
            passwordStatusEl.innerHTML = '<div class="error" style="margin-top:10px;">Error: Failed to save password: ' + e.message + '</div>';
            webUIPassword = oldPassword;
            updatePasswordStatus();
        }
    }
}

// Clear password from localStorage and reset UI
function clearPassword() {
    if (confirm('Are you sure you want to clear the saved password? You will need to re-enter it to use the web UI.')) {
        localStorage.removeItem('biginky_webui_password');
        webUIPassword = null;
        document.getElementById('webUIPassword').value = '';
        document.getElementById('passwordStatus').innerHTML = '<div class="info" style="margin-top:10px;">Password cleared. Please enter a new password and click Save Password.</div>';
        updatePasswordStatus();
        
        // Disconnect from MQTT if connected
        if (mqttClient && isConnected) {
            mqttClient.disconnect();
            isConnected = false;
            updateConnectionStatus('disconnected', 'Disconnected after password cleared');
        }
    }
}

// Derive HMAC key from password using HMAC-SHA256 with salt
async function deriveHMACKey(password) {
    const encoder = new TextEncoder();
    const salt = encoder.encode('biginky_hmac_key_v1');
    const passwordData = encoder.encode(password);
    
    // Import password as HMAC key
    const key = await crypto.subtle.importKey(
        'raw',
        passwordData,
        { name: 'HMAC', hash: 'SHA-256' },
        false,
        ['sign']
    );
    
    // Compute HMAC(password, salt) to derive key
    const derivedKey = await crypto.subtle.sign('HMAC', key, salt);
    return new Uint8Array(derivedKey);
}

// Derive encryption key from password using HMAC-SHA256 with salt
async function deriveEncryptionKey(password) {
    const encoder = new TextEncoder();
    const salt = encoder.encode('biginky_enc_key_v1');
    const passwordData = encoder.encode(password);
    
    // Debug: log password length and first few bytes
    console.log('deriveEncryptionKey: password length =', password.length);
    console.log('deriveEncryptionKey: password bytes (first 20) =', Array.from(passwordData.slice(0, 20)).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
    console.log('deriveEncryptionKey: salt =', Array.from(salt).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
    
    // Import password as HMAC key
    const key = await crypto.subtle.importKey(
        'raw',
        passwordData,
        { name: 'HMAC', hash: 'SHA-256' },
        false,
        ['sign']
    );
    
    // Compute HMAC(password, salt) to derive key
    const derivedKey = await crypto.subtle.sign('HMAC', key, salt);
    const keyArray = new Uint8Array(derivedKey);
    
    // Debug: log derived key (first 16 bytes)
    console.log('deriveEncryptionKey: derived key (first 16 bytes) =', Array.from(keyArray.slice(0, 16)).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
    
    return keyArray;
}

// Compute HMAC-SHA256 of a message using the derived HMAC key
async function computeHMAC(message) {
    if (!webUIPassword) {
        console.error('No password configured for HMAC computation');
        return null;
    }
    
    try {
        // Derive HMAC key from password
        const hmacKey = await deriveHMACKey(webUIPassword);
        
        // Import derived key
        const key = await crypto.subtle.importKey(
            'raw',
            hmacKey,
            { name: 'HMAC', hash: 'SHA-256' },
            false,
            ['sign']
        );
        
        // Sign the message
        const encoder = new TextEncoder();
        const messageData = encoder.encode(message);
        const signature = await crypto.subtle.sign('HMAC', key, messageData);
        
        // Convert to hex string
        const hashArray = Array.from(new Uint8Array(signature));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        return hashHex;
    } catch (e) {
        console.error('HMAC computation error:', e);
        return null;
    }
}

// Verify HMAC signature of a message
async function verifyHMAC(message, providedHMAC) {
    if (!webUIPassword) {
        console.warn('No password configured for HMAC verification');
        return false;
    }
    
    const computedHMAC = await computeHMAC(message);
    if (!computedHMAC) {
        return false;
    }
    
    // Constant-time comparison
    if (computedHMAC.length !== providedHMAC.length) {
        return false;
    }
    
    let result = 0;
    for (let i = 0; i < computedHMAC.length; i++) {
        result |= computedHMAC.charCodeAt(i) ^ providedHMAC.charCodeAt(i);
    }
    return result === 0;
}

function updateConnectionStatus(status, message) {
    const statusEl = document.getElementById('connectionStatus');
    const timestampEl = document.getElementById('connectionTimestamp');
    const msgEl = document.getElementById('connectionStatusMsg');
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    
    statusEl.className = 'connection-status ' + status;
    statusEl.textContent = status.charAt(0).toUpperCase() + status.slice(1);
    
    // Update timestamp
    if (timestampEl) {
        const now = new Date();
        timestampEl.textContent = now.toLocaleTimeString();
    }
    
    if (message) {
        msgEl.innerHTML = '<div class="' + (status === 'connected' ? 'status' : 'error') + '">' + message + '</div>';
    } else {
        msgEl.innerHTML = '';
    }
    
    // Update button states based on connection AND password
    const hasPassword = (webUIPassword && webUIPassword.length > 0);
    connectBtn.disabled = (status === 'connected' || status === 'connecting' || status === 'reconnecting' || !hasPassword);
    disconnectBtn.disabled = (status === 'disconnected');
    
    const buttons = ['textDisplayBtn', 'canvasDisplayBtn', 'clearBtn', 'nextBtn'];
    buttons.forEach(id => {
        const btn = document.getElementById(id);
        if (btn) {
            btn.disabled = (status !== 'connected' || !hasPassword);
        }
    });
}

// Update UI state based on password status
function updatePasswordStatus() {
    const hasPassword = (webUIPassword && webUIPassword.length > 0);
    const buttons = ['textDisplayBtn', 'canvasDisplayBtn', 'clearBtn', 'nextBtn', 'connectBtn'];
    
    buttons.forEach(id => {
        const btn = document.getElementById(id);
        if (btn) {
            if (id === 'connectBtn') {
                // Connect button disabled if no password
                btn.disabled = !hasPassword;
            } else {
                // Other buttons disabled if no password OR not connected
                btn.disabled = !hasPassword || !isConnected;
            }
        }
    });
    
    // Show warning if no password
    const passwordStatusEl = document.getElementById('passwordStatus');
    if (!hasPassword) {
        passwordStatusEl.innerHTML = '<div class="error" style="margin-top:10px;">‚ö†Ô∏è Password required: All functionality is disabled until a password is set.</div>';
    } else {
        passwordStatusEl.innerHTML = '<div class="status" style="margin-top:10px;">‚úì Password configured - interface enabled</div>';
    }
}

function logCommand(action, data) {
    const logEl = document.getElementById('commandLog');
    const timestamp = new Date().toLocaleTimeString();
    let logEntry = `[${timestamp}] `;
    
    // Simplify log messages
    if (action === 'PUBLISH' && data && data.command) {
        const command = data.command;
        // Map command names to user-friendly messages
        const commandMessages = {
            'text_display': 'Text display command sent',
            'canvas_display': 'Canvas display command sent',
            'clear': 'Clear display command sent',
            'next': 'Next media item command sent',
            'go': 'Show media item command sent'
        };
        logEntry += commandMessages[command] || `Command "${command}" sent`;
    } else if (action === 'MESSAGE_RECEIVED' && data && data.topic) {
        // Map topic to user-friendly messages
        if (data.topic === MQTT_TOPIC_STATUS) {
            logEntry += 'Status update received';
        } else if (data.topic === MQTT_TOPIC_THUMB) {
            logEntry += 'Thumbnail update received';
        } else if (data.topic === MQTT_TOPIC_MEDIA) {
            logEntry += 'Media mappings update received';
        } else {
            logEntry += 'Message received';
        }
    } else if (action === 'CONNECTED') {
        logEntry += 'Connected to MQTT broker';
    } else if (action === 'DISCONNECTED') {
        logEntry += 'Disconnected from MQTT broker';
    } else if (action === 'CONNECTION_FAILED') {
        logEntry += 'Connection failed';
    } else {
        // Fallback for unknown actions
        logEntry += action;
    }
    
    logEntry += '\n';
    logEl.textContent = logEntry + logEl.textContent;
    const lines = logEl.textContent.split('\n');
    if (lines.length > 50) {
        logEl.textContent = lines.slice(0, 50).join('\n');
    }
}

function updateDeviceStatus(status) {
    const statusEl = document.getElementById('deviceStatus');
    let html = '<div style="line-height:1.6;">';
    
    // Timestamp and current time
    if (status.timestamp) {
        const date = new Date(status.timestamp * 1000);
        html += `<p><strong>Last Update:</strong> ${date.toLocaleString()}</p>`;
    }
    if (status.current_time) {
        html += `<p><strong>Device Time:</strong> ${status.current_time}</p>`;
    }
    
    // Next media item
    if (status.next_media) {
        html += '<p><strong>Next Media:</strong> ';
        html += `<span style="color:#4CAF50;">${status.next_media.image}</span>`;
        if (status.next_media.audio) {
            html += ` <span style="color:#888;">(${status.next_media.audio})</span>`;
        }
        html += ` <span style="color:#888;font-size:11px;">[index ${status.next_media.index}]</span>`;
        html += '</p>';
    }
    
    // Next wake time
    if (status.next_wake) {
        html += `<p><strong>Next Wake:</strong> <span style="color:#2196F3;">${status.next_wake}</span>`;
        if (status.sleep_interval_minutes) {
            html += ` <span style="color:#888;font-size:11px;">(every ${status.sleep_interval_minutes} min)</span>`;
        }
        html += '</p>';
    }
    
    // Connection status
    if (status.connected !== undefined) {
        html += '<p><strong>Status:</strong> ';
        if (status.connected) {
            html += '<span style="color:#4CAF50;">Connected</span>';
        } else {
            html += '<span style="color:#f44336;">Disconnected</span>';
        }
        html += '</p>';
    }
    
    html += '</div>';
    statusEl.innerHTML = html;
}

function updateMediaMappingsTable(mappings) {
    const statusEl = document.getElementById('mediaMappingsStatus');
    const tableEl = document.getElementById('mediaMappingsTable');
    
    if (!mappings || mappings.length === 0) {
        statusEl.textContent = 'No media mappings available';
        tableEl.innerHTML = '<p style="color:#888;">No media mappings found.</p>';
        return;
    }
    
    statusEl.textContent = `Loaded ${mappings.length} media mapping(s) (updated ${new Date().toLocaleTimeString()})`;
    
    // Create table with optimized column widths
    let html = '<table style="width:100%;border-collapse:collapse;margin-top:10px;table-layout:fixed;">';
    html += '<thead><tr style="background:#333;color:#e0e0e0;">';
    html += '<th style="padding:8px;text-align:center;border:1px solid #555;width:5%;">#</th>';
    html += '<th style="padding:8px;text-align:center;border:1px solid #555;width:25%;">Thumbnail</th>';
    html += '<th style="padding:8px;text-align:left;border:1px solid #555;width:30%;">Image</th>';
    html += '<th style="padding:8px;text-align:left;border:1px solid #555;width:30%;">Audio</th>';
    html += '<th style="padding:8px;text-align:center;border:1px solid #555;width:10%;">Actions</th>';
    html += '</tr></thead><tbody>';
    
    for (let i = 0; i < mappings.length; i++) {
        const mapping = mappings[i];
        // Use 1-based index for display and commands (matching firmware convention)
        const displayIndex = mapping.index !== undefined ? mapping.index : (i + 1);
        html += '<tr style="border-bottom:1px solid #555;">';
        html += `<td style="padding:8px;border:1px solid #555;text-align:center;font-weight:bold;">${displayIndex}</td>`;
        
        // Thumbnail column - make thumbnails fill the column better
        html += '<td style="padding:8px;border:1px solid #555;text-align:center;vertical-align:middle;">';
        if (mapping.thumbnail) {
            html += `<img src="data:image/jpeg;base64,${mapping.thumbnail}" class="media-thumbnail" style="max-width:100%;max-height:150px;width:auto;height:auto;border:1px solid #666;display:block;margin:0 auto;" alt="Thumbnail" />`;
        } else {
            html += '<span style="color:#888;">No thumbnail</span>';
        }
        html += '</td>';
        
        // Image column - allow text wrapping
        html += `<td style="padding:8px;border:1px solid #555;word-wrap:break-word;overflow-wrap:break-word;">${mapping.image || 'N/A'}</td>`;
        
        // Audio column - allow text wrapping
        html += `<td style="padding:8px;border:1px solid #555;word-wrap:break-word;overflow-wrap:break-word;">${mapping.audio || '<span style="color:#888;">(none)</span>'}</td>`;
        
        // Actions column - Show button
        html += '<td style="padding:8px;border:1px solid #555;text-align:center;vertical-align:middle;">';
        html += `<button onclick="showMediaItem(${displayIndex})" style="padding:6px 12px;font-size:14px;background:#4CAF50;color:white;border:none;border-radius:4px;cursor:pointer;">Show</button>`;
        html += '</td>';
        
        html += '</tr>';
    }
    
    html += '</tbody></table>';
    tableEl.innerHTML = html;
    
    console.log(`Media mappings table updated with ${mappings.length} entries`);
}

function updateThumbnail(thumb) {
    const canvas = document.getElementById('thumbnailCanvas');
    const statusEl = document.getElementById('thumbnailStatus');
    
    if (!thumb || !thumb.data || !thumb.width || !thumb.height) {
        statusEl.textContent = 'Invalid thumbnail data';
        canvas.style.display = 'none';
        return;
    }
    
    // Set canvas size
    canvas.width = thumb.width;
    canvas.height = thumb.height;
    const ctx = canvas.getContext('2d');
    
    try {
        if (thumb.format === 'jpeg') {
            // JPEG format: create data URL and load as image (much simpler!)
            const dataUrl = 'data:image/jpeg;base64,' + thumb.data;
            const img = new Image();
            img.onload = function() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                canvas.style.display = 'block';
                statusEl.textContent = 'Preview: ' + thumb.width + 'x' + thumb.height + ' JPEG (updated ' + new Date().toLocaleTimeString() + ')';
                console.log('JPEG thumbnail updated successfully.');
            };
            img.onerror = function() {
                console.error('Failed to load JPEG thumbnail');
                statusEl.textContent = 'Error loading JPEG preview';
                canvas.style.display = 'none';
            };
            img.src = dataUrl;
        } else if (thumb.format === 'rgb888') {
            // Legacy RGB888 format: decode raw RGB data
            // Validate base64 data before decoding
            if (!/^[A-Za-z0-9+/=]+$/.test(thumb.data)) {
                console.error('Invalid base64 data in RGB888 thumbnail');
                statusEl.textContent = 'Error: Invalid base64 data in thumbnail';
                canvas.style.display = 'none';
                return;
            }
            
            // Validate expected data length
            const expectedBytes = thumb.width * thumb.height * 3;
            let binaryString;
            try {
                binaryString = atob(thumb.data);
            } catch (e) {
                console.error('Failed to decode base64 data:', e);
                statusEl.textContent = 'Error: Failed to decode base64 data. Message may be incomplete.';
                canvas.style.display = 'none';
                return;
            }
            
            if (binaryString.length !== expectedBytes) {
                console.error('RGB888 data length mismatch:', { 
                    expected: expectedBytes, 
                    actual: binaryString.length,
                    width: thumb.width,
                    height: thumb.height
                });
                statusEl.textContent = 'Error: Thumbnail data incomplete. Expected ' + expectedBytes + ' bytes, got ' + binaryString.length + '.';
                canvas.style.display = 'none';
                return;
            }
            
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            
            // Create ImageData from RGB888 data
            const imageData = ctx.createImageData(thumb.width, thumb.height);
            const data = imageData.data;
            
            // Convert RGB888 to RGBA8888
            for (let i = 0; i < bytes.length; i += 3) {
                const pixelIdx = (i / 3) * 4;
                if (pixelIdx + 3 < data.length) {
                    data[pixelIdx + 0] = bytes[i + 0];     // R
                    data[pixelIdx + 1] = bytes[i + 1];     // G
                    data[pixelIdx + 2] = bytes[i + 2];     // B
                    data[pixelIdx + 3] = 255;               // A (opaque)
                }
            }
            
            // Draw to canvas
            try {
                ctx.putImageData(imageData, 0, 0);
                canvas.style.display = 'block';
                statusEl.textContent = 'Preview: ' + thumb.width + 'x' + thumb.height + ' RGB888 (updated ' + new Date().toLocaleTimeString() + ')';
            } catch (drawError) {
                console.error('Failed to draw RGB888 thumbnail to canvas:', drawError);
                statusEl.textContent = 'Error drawing thumbnail to canvas';
                canvas.style.display = 'none';
            }
        } else {
            statusEl.textContent = 'Unsupported thumbnail format: ' + thumb.format;
            canvas.style.display = 'none';
        }
    } catch (e) {
        console.error('Error updating thumbnail:', e);
        statusEl.textContent = 'Error displaying thumbnail: ' + e.message;
        canvas.style.display = 'none';
    }
}

function connectMQTT() {
    console.log('connectMQTT() called');
    
    // Require password before connecting
    if (!webUIPassword || webUIPassword.length === 0) {
        updateConnectionStatus('disconnected', 'Error: Password required. Please set password in Authentication section above.');
        return;
    }
    
    // Always use embedded token
    const token = EMBEDDED_TOKEN;
    
    if (!token || token === 'YOUR_RESTRICTED_TOKEN_HERE') {
        console.log('Embedded token not configured');
        updateConnectionStatus('disconnected', 'Error: Embedded token not configured');
        return;
    }
    
    if (mqttClient && isConnected) {
        console.log('Already connected');
        return;
    }
    
    console.log('Starting connection to', MQTT_BROKER, 'port', MQTT_PORT);
    updateConnectionStatus('connecting', 'Connecting to MQTT broker...');
    
    // Check if Paho MQTT library is loaded
    if (!pahoLibraryLoaded && !checkPahoLoaded()) {
        console.error('Paho MQTT library not loaded!', { 
            Paho: typeof Paho, 
            Client: typeof (typeof Paho !== 'undefined' ? Paho.Client : undefined),
            Message: typeof (typeof Paho !== 'undefined' ? Paho.Message : undefined),
            pahoLibraryLoaded: pahoLibraryLoaded
        });
        updateConnectionStatus('disconnected', 'Error: MQTT library not loaded. Please wait a moment and try again.');
        // Try waiting a bit and retry
        setTimeout(function() {
            if (checkPahoLoaded()) {
                console.log('Library now available, retrying connection...');
                connectMQTT();
            } else {
                console.error('Library still not available after wait');
            }
        }, 1000);
        return;
    }
    
    const clientId = 'biginky_web_' + Math.random().toString(16).substr(2, 8);
    console.log('Creating MQTT client with ID:', clientId);
    console.log('Paho.Client available:', typeof Paho.Client);
    
    try {
        mqttClient = new Paho.Client(MQTT_BROKER, MQTT_PORT, '/mqtt', clientId);
        console.log('MQTT client created successfully');
    } catch (e) {
        console.error('Failed to create MQTT client:', e);
        updateConnectionStatus('disconnected', 'Error creating MQTT client: ' + e.message);
        return;
    }
    
    mqttClient.onConnectionLost = function(responseObject) {
        console.log('Connection lost:', responseObject);
        isConnected = false;
        updateConnectionStatus('disconnected', 'Connection lost: ' + (responseObject.errorMessage || 'Unknown error'));
        updatePasswordStatus();  // Update button states
        logCommand('DISCONNECTED', { reason: responseObject.errorMessage });
        
        // Auto-reconnect if enabled
        if (autoReconnectEnabled && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
            scheduleReconnect();
        }
    };
    
    mqttClient.onMessageArrived = async function(message) {
        console.log('Message received:', message);
        logCommand('MESSAGE_RECEIVED', { topic: message.destinationName });
        
        // Handle status messages
        if (message.destinationName === MQTT_TOPIC_STATUS) {
            console.log('Status message received, parsing...');
            try {
                const payload = JSON.parse(message.payloadString);
                console.log('Parsed status:', payload);
                
                // Check if message is encrypted
                let status = payload;
                
                if (payload.encrypted && payload.payload) {
                    // Validate encrypted message structure
                    if (!payload.iv || !payload.payload) {
                        console.error('Invalid encrypted message structure - missing iv or payload');
                        document.getElementById('deviceStatus').innerHTML = '<p style="color:#f44336;">Error: Invalid encrypted message structure. Message may be incomplete.</p>';
                        return;
                    }
                    
                    // Verify HMAC first (on encrypted message)
                    if (webUIPassword && payload.hmac) {
                        const providedHMAC = payload.hmac;
                        const messageForHMAC = JSON.stringify({ encrypted: true, iv: payload.iv, payload: payload.payload });
                        
                        const hmacValid = await verifyHMAC(messageForHMAC, providedHMAC);
                        if (!hmacValid) {
                            console.error('Status message HMAC verification failed');
                            document.getElementById('deviceStatus').innerHTML = '<p style="color:#f44336;">Error: HMAC verification failed. Password may be incorrect.</p>';
                            return;
                        }
                        console.log('HMAC verification passed - password is correct for HMAC');
                    } else {
                        console.warn('No password or HMAC provided - cannot verify message authenticity');
                    }
                    
                    // Decrypt the payload
                    let decrypted;
                    try {
                        decrypted = await decryptMessage(payload.payload, payload.iv);
                    } catch (decryptError) {
                        console.error('Failed to decrypt status message:', decryptError);
                        document.getElementById('deviceStatus').innerHTML = '<p style="color:#f44336;">Error: Failed to decrypt status message. <strong>Password mismatch detected</strong> - HMAC passed but decryption failed. Please verify the password matches the device password.</p>';
                        return;
                    }
                    
                    if (!decrypted || decrypted.length === 0) {
                        console.error('Decryption returned empty result');
                        document.getElementById('deviceStatus').innerHTML = '<p style="color:#f44336;">Error: Decryption failed - empty result. <strong>Password mismatch detected</strong> - HMAC passed but decryption failed. Please verify the password matches the device password.</p>';
                        return;
                    }
                    
                    // Debug: log first few characters of decrypted data
                    console.log('Decrypted data (first 100 chars):', decrypted.substring(0, 100));
                    console.log('Decrypted data length:', decrypted.length);
                    
                    // Parse decrypted JSON
                    try {
                        status = JSON.parse(decrypted);
                    } catch (parseError) {
                        console.error('Failed to parse decrypted status JSON:', parseError);
                        console.error('Decrypted data (full):', decrypted);
                        document.getElementById('deviceStatus').innerHTML = '<p style="color:#f44336;">Error: Invalid status data after decryption. Message may be incomplete or corrupted.</p>';
                        return;
                    }
                    
                    console.log('Decrypted status:', status);
                } else if (webUIPassword && payload.hmac) {
                    // Unencrypted but has HMAC - verify it
                    const providedHMAC = payload.hmac;
                    delete payload.hmac;
                    const messageForHMAC = JSON.stringify(payload);
                    
                    const hmacValid = await verifyHMAC(messageForHMAC, providedHMAC);
                    if (!hmacValid) {
                        console.error('Status message HMAC verification failed');
                        document.getElementById('deviceStatus').innerHTML = '<p style="color:#f44336;">Error: HMAC verification failed. Password may be incorrect.</p>';
                        return;
                    }
                    status = payload;
                    console.log('Status message HMAC verified successfully (unencrypted)');
                } else {
                    // No password configured or no HMAC - just display (for backward compatibility)
                    if (!webUIPassword) {
                        console.warn('No password configured - cannot verify HMAC');
                    }
                    status = payload;
                }
                
                // Display status
                updateDeviceStatus(status);
                
                // Check for pending_action and update busy state
                if (status.pending_action) {
                    setBusyState(true, 'Device is processing: ' + status.pending_action);
                } else if (isBusy) {
                    // No pending action means command completed
                    clearTimeout(busyTimeoutId);
                    busyTimeoutId = null;
                    setBusyState(false);
                }
            } catch (e) {
                console.error('Failed to parse/decrypt status message:', e);
                document.getElementById('deviceStatus').innerHTML = '<p style="color:#f44336;">Error parsing status message: ' + e.message + '</p>';
            }
        } else if (message.destinationName === MQTT_TOPIC_THUMB) {
            console.log('Thumbnail message received, parsing...');
            try {
                const payload = JSON.parse(message.payloadString);
                console.log('Parsed payload:', payload);
                
                // Check if message is encrypted
                let thumb = payload;
                let isEncrypted = false;
                
                if (payload.encrypted && payload.payload) {
                    isEncrypted = true;
                    console.log('Thumbnail message is encrypted, decrypting...');
                    
                    // Validate encrypted message structure
                    if (!payload.iv || !payload.payload) {
                        console.error('Invalid encrypted message structure - missing iv or payload');
                        document.getElementById('thumbnailStatus').textContent = 'Error: Invalid encrypted message structure. Message may be incomplete.';
                        return;
                    }
                    
                    // Verify HMAC first (on encrypted message)
                    if (webUIPassword && payload.hmac) {
                        const providedHMAC = payload.hmac;
                        const messageForHMAC = JSON.stringify({ encrypted: true, iv: payload.iv, payload: payload.payload });
                        
                        const hmacValid = await verifyHMAC(messageForHMAC, providedHMAC);
                        if (!hmacValid) {
                            console.error('Thumbnail message HMAC verification failed');
                            document.getElementById('thumbnailStatus').textContent = 'Error: HMAC verification failed. Password may be incorrect.';
                            return;
                        }
                    }
                    
                    // Decrypt the payload
                    let decrypted;
                    try {
                        decrypted = await decryptMessage(payload.payload, payload.iv);
                    } catch (decryptError) {
                        console.error('Failed to decrypt thumbnail message:', decryptError);
                        document.getElementById('thumbnailStatus').textContent = 'Error: Failed to decrypt thumbnail message. Password may be incorrect or message corrupted.';
                        return;
                    }
                    
                    if (!decrypted || decrypted.length === 0) {
                        console.error('Decryption returned empty result');
                        document.getElementById('thumbnailStatus').textContent = 'Error: Decryption failed - empty result. Message may be corrupted.';
                        return;
                    }
                    
                    // Parse decrypted JSON
                    try {
                        thumb = JSON.parse(decrypted);
                    } catch (parseError) {
                        console.error('Failed to parse decrypted thumbnail JSON:', parseError);
                        document.getElementById('thumbnailStatus').textContent = 'Error: Invalid thumbnail data after decryption. Message may be incomplete or corrupted.';
                        return;
                    }
                    
                    // Validate decrypted thumbnail structure
                    if (!thumb || typeof thumb.width !== 'number' || typeof thumb.height !== 'number' || !thumb.format || !thumb.data) {
                        console.error('Invalid thumbnail structure after decryption:', thumb);
                        document.getElementById('thumbnailStatus').textContent = 'Error: Invalid thumbnail structure. Message may be incomplete.';
                        return;
                    }
                    
                    console.log('Decrypted thumbnail:', { width: thumb.width, height: thumb.height, format: thumb.format, dataLength: thumb.data ? thumb.data.length : 0 });
                } else if (webUIPassword && payload.hmac) {
                    // Unencrypted but has HMAC - verify it
                    const providedHMAC = payload.hmac;
                    delete payload.hmac;
                    const messageForHMAC = JSON.stringify(payload);
                    
                    const hmacValid = await verifyHMAC(messageForHMAC, providedHMAC);
                    if (!hmacValid) {
                        console.error('Thumbnail message HMAC verification failed');
                        document.getElementById('thumbnailStatus').textContent = 'Error: HMAC verification failed. Password may be incorrect.';
                        return;
                    }
                    thumb = payload;
                    console.log('Thumbnail message HMAC verified successfully (unencrypted)');
                } else {
                    // No password configured or no HMAC - just display (for backward compatibility)
                    if (!webUIPassword) {
                        console.warn('No password configured - cannot verify HMAC');
                    }
                    thumb = payload;
                }
                
                // Validate thumbnail structure before displaying
                if (!thumb || typeof thumb.width !== 'number' || typeof thumb.height !== 'number' || !thumb.format || !thumb.data) {
                    console.error('Invalid thumbnail structure:', thumb);
                    document.getElementById('thumbnailStatus').textContent = 'Error: Invalid thumbnail structure. Required fields missing.';
                    return;
                }
                
                // Validate data length matches expected size for the format
                if (thumb.format === 'jpeg' || thumb.format === 'rgb888') {
                    const expectedDataLength = thumb.format === 'jpeg' 
                        ? undefined  // JPEG can vary in size
                        : thumb.width * thumb.height * 3;  // RGB888: width * height * 3 bytes
                    
                    if (thumb.format === 'rgb888' && thumb.data.length < expectedDataLength) {
                        console.error('Thumbnail data incomplete:', { 
                            expected: expectedDataLength, 
                            actual: thumb.data.length,
                            width: thumb.width,
                            height: thumb.height
                        });
                        document.getElementById('thumbnailStatus').textContent = 'Error: Thumbnail data incomplete. Expected ' + expectedDataLength + ' bytes, got ' + thumb.data.length + '.';
                        return;
                    }
                }
                
                // All validations passed - safe to display
                updateThumbnail(thumb);
            } catch (e) {
                console.error('Failed to parse/decrypt thumbnail message:', e);
                document.getElementById('thumbnailStatus').textContent = 'Error parsing thumbnail message: ' + e.message;
            }
        } else if (message.destinationName === MQTT_TOPIC_MEDIA) {
            console.log('Media mappings message received, parsing...');
            try {
                const payload = JSON.parse(message.payloadString);
                console.log('Parsed media payload:', payload);
                
                // Check if message is encrypted
                let mediaData = payload;
                
                if (payload.encrypted && payload.payload) {
                    // Validate encrypted message structure
                    if (!payload.iv || !payload.payload) {
                        console.error('Invalid encrypted message structure - missing iv or payload');
                        document.getElementById('mediaMappingsStatus').textContent = 'Error: Invalid encrypted message structure. Message may be incomplete.';
                        return;
                    }
                    
                    // Verify HMAC first
                    if (webUIPassword && payload.hmac) {
                        const providedHMAC = payload.hmac;
                        const messageForHMAC = JSON.stringify({ encrypted: true, iv: payload.iv, payload: payload.payload });
                        
                        const hmacValid = await verifyHMAC(messageForHMAC, providedHMAC);
                        if (!hmacValid) {
                            console.error('Media mappings message HMAC verification failed');
                            document.getElementById('mediaMappingsStatus').textContent = 'Error: HMAC verification failed. Password may be incorrect.';
                            return;
                        }
                    }
                    
                    // Decrypt the payload
                    let decrypted;
                    try {
                        decrypted = await decryptMessage(payload.payload, payload.iv);
                    } catch (decryptError) {
                        console.error('Failed to decrypt media mappings message:', decryptError);
                        document.getElementById('mediaMappingsStatus').textContent = 'Error: Failed to decrypt media mappings. Password may be incorrect or message corrupted.';
                        return;
                    }
                    
                    if (!decrypted || decrypted.length === 0) {
                        console.error('Decryption returned empty result');
                        document.getElementById('mediaMappingsStatus').textContent = 'Error: Decryption failed - empty result. Message may be corrupted.';
                        return;
                    }
                    
                    // Parse decrypted JSON
                    try {
                        mediaData = JSON.parse(decrypted);
                    } catch (parseError) {
                        console.error('Failed to parse decrypted media mappings JSON:', parseError);
                        document.getElementById('mediaMappingsStatus').textContent = 'Error: Invalid media mappings data after decryption. Message may be incomplete or corrupted.';
                        return;
                    }
                    
                    console.log('Decrypted media mappings:', { mappingCount: mediaData.mappings ? mediaData.mappings.length : 0 });
                } else if (webUIPassword && payload.hmac) {
                    // Unencrypted but has HMAC - verify it
                    const providedHMAC = payload.hmac;
                    delete payload.hmac;
                    const messageForHMAC = JSON.stringify(payload);
                    
                    const hmacValid = await verifyHMAC(messageForHMAC, providedHMAC);
                    if (!hmacValid) {
                        console.error('Media mappings message HMAC verification failed');
                        document.getElementById('mediaMappingsStatus').textContent = 'Error: HMAC verification failed. Password may be incorrect.';
                        return;
                    }
                    mediaData = payload;
                } else {
                    // No password configured or no HMAC - just display (for backward compatibility)
                    if (!webUIPassword) {
                        console.warn('No password configured - cannot verify HMAC');
                    }
                    mediaData = payload;
                }
                
                // Validate media data structure
                if (!mediaData || !mediaData.mappings || !Array.isArray(mediaData.mappings)) {
                    console.error('Invalid media mappings structure:', mediaData);
                    document.getElementById('mediaMappingsStatus').textContent = 'Error: Invalid media mappings structure. Required fields missing.';
                    return;
                }
                
                // Display media mappings table
                updateMediaMappingsTable(mediaData.mappings);
            } catch (e) {
                console.error('Failed to parse/decrypt media mappings message:', e);
                document.getElementById('mediaMappingsStatus').textContent = 'Error parsing media mappings message: ' + e.message;
            }
        } else {
            console.log('Message on different topic, ignoring:', message.destinationName);
        }
    };
    
    const connectOptions = {
        userName: token,
        password: '',
        useSSL: true,
        onSuccess: function() {
            console.log('Connection successful!');
            isConnected = true;
            cancelReconnect(); // Reset reconnect attempts on successful connection
            reconnectAttempts = 0;
            updateConnectionStatus('connected', 'Connected successfully!');
            updatePasswordStatus();  // Update button states
            logCommand('CONNECTED', { broker: MQTT_BROKER, topic: MQTT_TOPIC });
            
            // Update status display to show we're waiting for status
            document.getElementById('deviceStatus').innerHTML = '<p style="color:#ff9800;">Connected - waiting for device status...</p>';
            
            // Subscribe to status, thumbnail, and media topics
            mqttClient.subscribe(MQTT_TOPIC_STATUS, { qos: 1 });
            mqttClient.subscribe(MQTT_TOPIC_THUMB, { qos: 1 });
            mqttClient.subscribe(MQTT_TOPIC_MEDIA, { qos: 1 });
            console.log('Subscribed to status topic:', MQTT_TOPIC_STATUS);
            console.log('Subscribed to thumbnail topic:', MQTT_TOPIC_THUMB);
            console.log('Subscribed to media topic:', MQTT_TOPIC_MEDIA);
            
            // If no status message arrives within 3 seconds, show a message
            setTimeout(function() {
                const statusEl = document.getElementById('deviceStatus');
                if (statusEl.innerHTML.includes('waiting for device status')) {
                    statusEl.innerHTML = '<p style="color:#ff9800;">Connected - no status received yet (device may not have published status)</p>';
                }
            }, 3000);
        },
        onFailure: function(error) {
            console.error('Connection failed:', error);
            isConnected = false;
            const errorMsg = error.errorMessage || error.toString() || 'Unknown error';
            updateConnectionStatus('disconnected', 'Connection failed: ' + errorMsg);
            updatePasswordStatus();  // Update button states
            logCommand('CONNECTION_FAILED', { error: errorMsg });
            mqttClient = null;
        },
        timeout: 10,
        keepAliveInterval: 60
    };
    
    console.log('Attempting to connect with options:', { userName: token.substring(0, 10) + '...', useSSL: true });
    try {
        mqttClient.connect(connectOptions);
        console.log('connect() called');
    } catch (e) {
        console.error('Exception during connect():', e);
        updateConnectionStatus('disconnected', 'Error: ' + e.message);
    }
}

function disconnectMQTT() {
    if (mqttClient && isConnected) {
        mqttClient.disconnect();
        mqttClient = null;
        isConnected = false;
        updateConnectionStatus('disconnected', 'Disconnected');
        logCommand('DISCONNECTED', { reason: 'User requested' });
        
        // Clear device status
        document.getElementById('deviceStatus').innerHTML = '<p>Not connected - status appears when connected</p>';
    }
}

async function publishMessage(payload) {
    // Check if password is configured FIRST (before connection check)
    if (!webUIPassword || webUIPassword.length === 0) {
        showStatus('commandStatus', 'Error: Password required. Please set password in Authentication section above.', true);
        return false;
    }
    
    if (!mqttClient || !isConnected) {
        showStatus('commandStatus', 'Not connected to MQTT broker', true);
        return false;
    }
    
    try {
        // Encrypt the payload
        const plaintext = JSON.stringify(payload);
        const encryptedPayload = await encryptMessage(plaintext);
        
        if (!encryptedPayload) {
            showStatus('commandStatus', 'Error: Failed to encrypt message', true);
            return false;
        }
        
        // Create encrypted message structure
        const encryptedMessage = {
            encrypted: true,
            payload: encryptedPayload
        };
        
        // Compute HMAC of encrypted message (without hmac field)
        const messageForHMAC = JSON.stringify(encryptedMessage);
        const hmac = await computeHMAC(messageForHMAC);
        
        if (!hmac) {
            showStatus('commandStatus', 'Error: Failed to compute HMAC signature', true);
            return false;
        }
        
        // Add HMAC to encrypted message
        encryptedMessage.hmac = hmac;
        
        const message = new Paho.Message(JSON.stringify(encryptedMessage));
        message.destinationName = MQTT_TOPIC;
        message.qos = 1;
        message.retained = true;  // Use retained messages so device receives them when it wakes up
        mqttClient.send(message);
        logCommand('PUBLISH', { command: payload.command, encrypted: true });
        return true;
    } catch (error) {
        showStatus('commandStatus', 'Failed to send message: ' + error, true);
        return false;
    }
}

async function sendTextDisplay() {
    const text = document.getElementById('textInput').value.trim();
    if (text.length === 0) {
        showStatus('textStatus', 'Please enter some text', true);
        return;
    }
    
    const color = document.getElementById('textColor').value;
    const bgColor = document.getElementById('textBackgroundColor').value;
    const outlineColor = document.getElementById('textOutlineColor').value;
    
    showStatus('textStatus', 'Sending text display command...', false);
    
    const payload = {
        command: 'text_display',
        text: text,
        color: color,
        backgroundColour: bgColor,
        outlineColour: outlineColor
    };
    
    if (await publishMessage(payload)) {
        showStatus('textStatus', 'Text display command sent successfully!', false);
        setBusyState(true, 'Command sent, waiting for device response...');
    } else {
        showStatus('textStatus', 'Failed to send command', true);
    }
}

async function sendCanvasToDisplay() {
    console.log('sendCanvasToDisplay() called');
    const canvas = document.getElementById('drawCanvas');
    if (!canvas) {
        console.error('Canvas element not found');
        showStatus('canvasStatus', 'Error: Canvas not found', true);
        return;
    }
    const ctx = canvas.getContext('2d');
    if (!ctx) {
        console.error('Could not get canvas context');
        showStatus('canvasStatus', 'Error: Could not access canvas', true);
        return;
    }
    try {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
    
    const einkColors = [[0,0,0],[255,255,255],[255,255,0],[255,0,0],[0,0,255],[0,255,0]];
    const einkColorValues = [0,1,2,3,5,6];
    
    function findClosestColorIdx(r, g, b) {
        let minDist = Infinity;
        let closestIdx = 0;
        for (let i = 0; i < einkColors.length; i++) {
            const ec = einkColors[i];
            const dist = Math.pow(r-ec[0],2) + Math.pow(g-ec[1],2) + Math.pow(b-ec[2],2);
            if (dist < minDist) {
                minDist = dist;
                closestIdx = i;
            }
        }
        return closestIdx;
    }
    
    const pixelData = [];
    for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i+1];
        const b = data[i+2];
        const arrayIdx = findClosestColorIdx(r, g, b);
        const einkColorValue = einkColorValues[arrayIdx];
        pixelData.push(einkColorValue);
    }
    
    const pixelBytes = new Uint8Array(pixelData);
    const rawSizeKB = (pixelBytes.length / 1024).toFixed(1);
    showStatus('canvasStatus', 'Compressing pixel data (' + rawSizeKB + ' KB raw)...', false);
    
    // Try to compress using browser's CompressionStream API (deflate/zlib)
    if (typeof CompressionStream !== 'undefined') {
        const stream = new CompressionStream('deflate');
        const writer = stream.writable.getWriter();
        const reader = stream.readable.getReader();
        
        writer.write(pixelBytes).then(() => writer.close());
        
        const compressedChunks = [];
        function pump() {
            return reader.read().then(({done, value}) => {
                if (done) return;
                compressedChunks.push(value);
                return pump();
            });
        }
        
        pump().then(() => {
            const compressedLength = compressedChunks.reduce((sum, chunk) => sum + chunk.length, 0);
            const compressed = new Uint8Array(compressedLength);
            let offset = 0;
            compressedChunks.forEach(chunk => {
                compressed.set(chunk, offset);
                offset += chunk.length;
            });
            
            // Convert compressed Uint8Array to binary string in chunks
            let binaryString = '';
            const chunkSize = 8192;
            for (let i = 0; i < compressed.length; i += chunkSize) {
                const chunk = compressed.slice(i, i + chunkSize);
                binaryString += String.fromCharCode.apply(null, Array.from(chunk));
            }
            const base64Data = btoa(binaryString);
            
            const compressedSizeKB = (compressed.length / 1024).toFixed(1);
            const base64SizeKB = (base64Data.length / 1024).toFixed(1);
            const ratio = ((compressed.length / pixelBytes.length) * 100).toFixed(1);
            const savedKB = ((pixelBytes.length - compressed.length) / 1024).toFixed(1);
            const jsonSize = JSON.stringify({pixelData: base64Data, width: canvas.width, height: canvas.height, compressed: true}).length;
            const jsonSizeKB = (jsonSize / 1024).toFixed(1);
            
            showStatus('canvasStatus', 'Compressed: ' + compressedSizeKB + ' KB binary (' + base64SizeKB + ' KB base64), ' + ratio + '% of ' + rawSizeKB + ' KB raw. Saved: ' + savedKB + ' KB. Total JSON: ' + jsonSizeKB + ' KB', false);
            
            const payload = {
                command: 'canvas_display',
                pixelData: base64Data,
                width: canvas.width,
                height: canvas.height,
                compressed: true
            };
            
            publishMessage(payload).then(success => {
                if (success) {
                    showStatus('canvasStatus', 'Canvas display command sent successfully!', false);
                    setBusyState(true, 'Command sent, waiting for device response...');
                } else {
                    showStatus('canvasStatus', 'Failed to send command', true);
                }
            });
        }).catch(e => {
            console.error('Compression error:', e);
            showStatus('canvasStatus', 'Compression error: ' + e + ', sending uncompressed', true);
            // Fallback to uncompressed
            let binaryString = '';
            const chunkSize = 8192;
            for (let i = 0; i < pixelBytes.length; i += chunkSize) {
                const chunk = pixelBytes.slice(i, i + chunkSize);
                binaryString += String.fromCharCode.apply(null, Array.from(chunk));
            }
            const base64Data = btoa(binaryString);
            const base64SizeKB = (base64Data.length / 1024).toFixed(1);
            const jsonSize = JSON.stringify({pixelData: base64Data, width: canvas.width, height: canvas.height, compressed: false}).length;
            const jsonSizeKB = (jsonSize / 1024).toFixed(1);
            showStatus('canvasStatus', 'Uncompressed: ' + rawSizeKB + ' KB raw (' + base64SizeKB + ' KB base64). Total JSON: ' + jsonSizeKB + ' KB (compression not available)', false);
            
            const payload = {
                command: 'canvas_display',
                pixelData: base64Data,
                width: canvas.width,
                height: canvas.height,
                compressed: false
            };
            
            publishMessage(payload).then(success => {
                if (success) {
                    showStatus('canvasStatus', 'Canvas display command sent successfully!', false);
                    setBusyState(true, 'Command sent, waiting for device response...');
                } else {
                    showStatus('canvasStatus', 'Failed to send command', true);
                }
            });
        });
    } else {
        // Compression not available - send uncompressed
        let binaryString = '';
        const chunkSize = 8192;
        for (let i = 0; i < pixelBytes.length; i += chunkSize) {
            const chunk = pixelBytes.slice(i, i + chunkSize);
            binaryString += String.fromCharCode.apply(null, Array.from(chunk));
        }
        const base64Data = btoa(binaryString);
        const base64SizeKB = (base64Data.length / 1024).toFixed(1);
        const jsonSize = JSON.stringify({pixelData: base64Data, width: canvas.width, height: canvas.height, compressed: false}).length;
        const jsonSizeKB = (jsonSize / 1024).toFixed(1);
        showStatus('canvasStatus', 'Uncompressed: ' + rawSizeKB + ' KB raw (' + base64SizeKB + ' KB base64). Total JSON: ' + jsonSizeKB + ' KB (compression not available)', false);
        
        const payload = {
            command: 'canvas_display',
            pixelData: base64Data,
            width: canvas.width,
            height: canvas.height,
            compressed: false
        };
        
        publishMessage(payload).then(success => {
            if (success) {
                showStatus('canvasStatus', 'Canvas display command sent successfully!', false);
            } else {
                showStatus('canvasStatus', 'Failed to send command', true);
            }
        });
    }
    } catch (error) {
        console.error('Error in sendCanvasToDisplay:', error);
        showStatus('canvasStatus', 'Error: ' + error.message, true);
    }
}

async function sendCommand(cmd) {
    const payload = { command: cmd };
    
    if (await publishMessage(payload)) {
        showStatus('commandStatus', cmd + ' command sent successfully!', false);
    } else {
        showStatus('commandStatus', 'Failed to send command', true);
    }
}

async function showMediaItem(index) {
    // Send go command with parameter (1-based index)
    const payload = {
        command: 'go',
        parameter: String(index)  // Convert to string as firmware expects string parameter
    };
    
    if (await publishMessage(payload)) {
        showStatus('mediaMappingsStatus', `Show command sent for item ${index}. Display will update in 20-30 seconds...`, false);
        setBusyState(true, 'Displaying media item ' + index + '... Please wait for device to respond.');
    } else {
        showStatus('mediaMappingsStatus', 'Failed to send show command', true);
    }
}

function setBusyState(busy, message) {
    // Clear any existing timeout
    if (busyTimeoutId) {
        clearTimeout(busyTimeoutId);
        busyTimeoutId = null;
    }
    
    isBusy = busy;
    const overlay = document.getElementById('busyOverlay');
    if (overlay) {
        if (busy) {
            overlay.classList.add('active');
            const msgEl = overlay.querySelector('.message');
            if (msgEl && message) {
                msgEl.textContent = message;
            }
            
            // Set timeout: if no status message arrives within 10 seconds, assume device might be asleep
            busyTimeoutId = setTimeout(() => {
                if (isBusy) {
                    // Device might be asleep - update message but keep busy state
                    const msgEl = overlay.querySelector('.message');
                    if (msgEl) {
                        msgEl.textContent = 'Device may be asleep. Command will be processed when device wakes. Waiting for status...';
                    }
                }
            }, 10000);  // 10 seconds
        } else {
            overlay.classList.remove('active');
        }
    }
}

function showStatus(id, msg, isError) {
    const el = document.getElementById(id);
    el.textContent = msg;
    el.className = isError ? 'error status' : 'status';
}

let canvas = document.getElementById('drawCanvas');
let ctx = canvas.getContext('2d');
let isDrawing = false;
let lastX = 0;
let lastY = 0;
let startX = 0;
let startY = 0;
let canvasHistory = [];
let historyIndex = -1;

const colorMap = {0:'#000000',1:'#FFFFFF',2:'#FFFF00',3:'#FF0000',5:'#0000FF',6:'#00FF00'};

const colorMap = {
    0: '#000000',  // Black
    1: '#FFFFFF',  // White
    2: '#FFFF00',  // Yellow
    3: '#FF0000',  // Red
    5: '#0000FF',  // Blue
    6: '#00FF00'   // Green
};

function getDrawColor() {
    const val = parseInt(document.getElementById('drawColor').value);
    return colorMap[val] || '#000000';
}

function getFillColor() {
    const val = parseInt(document.getElementById('fillColor').value);
    return colorMap[val] || '#FFFFFF';
}

function getOutlineColor() {
    const val = parseInt(document.getElementById('outlineColor').value);
    return colorMap[val] || '#000000';
}

function setTool(tool) {
    document.getElementById('drawTool').value = tool;
    // Update active button
    document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
    const toolBtn = document.getElementById('tool-' + tool);
    if (toolBtn) {
        toolBtn.classList.add('active');
    }
    // Trigger change event to update UI
    document.getElementById('drawTool').dispatchEvent(new Event('change'));
}

function getCurrentTool() {
    return document.getElementById('drawTool').value || 'brush';
}

// Initialize tool on page load
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
        setTool('brush');
    });
} else {
    setTool('brush');
}

function getCanvasCoordinates(e) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const clientX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
    const clientY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
    return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
    };
}

function saveCanvasState() {
    // Save current canvas state for undo
    historyIndex++;
    canvasHistory = canvasHistory.slice(0, historyIndex);
    canvasHistory.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
    if (canvasHistory.length > 20) {
        canvasHistory.shift();
        historyIndex--;
    }
    document.getElementById('undoBtn').disabled = historyIndex < 0;
}

function restoreCanvasState() {
    if (historyIndex >= 0) {
        ctx.putImageData(canvasHistory[historyIndex], 0, 0);
        historyIndex--;
        document.getElementById('undoBtn').disabled = historyIndex < 0;
    }
}

// Flood fill algorithm
function floodFill(x, y, fillColor) {
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const targetColor = getPixelColor(data, x, y, canvas.width);
    const fillR = parseInt(fillColor.substring(1, 3), 16);
    const fillG = parseInt(fillColor.substring(3, 5), 16);
    const fillB = parseInt(fillColor.substring(5, 7), 16);
    
    if (targetColor.r === fillR && targetColor.g === fillG && targetColor.b === fillB) {
        return; // Already filled with this color
    }
    
    const stack = [[x, y]];
    const visited = new Set();
    
    while (stack.length > 0) {
        const [cx, cy] = stack.pop();
        const key = `${cx},${cy}`;
        
        if (visited.has(key) || cx < 0 || cx >= canvas.width || cy < 0 || cy >= canvas.height) {
            continue;
        }
        
        const pixelColor = getPixelColor(data, cx, cy, canvas.width);
        if (pixelColor.r !== targetColor.r || pixelColor.g !== targetColor.g || pixelColor.b !== targetColor.b) {
            continue;
        }
        
        visited.add(key);
        const idx = (cy * canvas.width + cx) * 4;
        data[idx] = fillR;
        data[idx + 1] = fillG;
        data[idx + 2] = fillB;
        data[idx + 3] = 255;
        
        stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
    }
    
    ctx.putImageData(imageData, 0, 0);
}

function getPixelColor(data, x, y, width) {
    const idx = (y * width + x) * 4;
    return {
        r: data[idx],
        g: data[idx + 1],
        b: data[idx + 2],
        a: data[idx + 3]
    };
}

// Posterize image to match e-ink colors using Floyd-Steinberg dithering
function posterizeImage(x, y, width, height) {
    const einkColors = [[0,0,0],[255,255,255],[255,255,0],[255,0,0],[0,0,255],[0,255,0]];
    
    function findClosestColorIdx(r, g, b) {
        let minDist = Infinity;
        let closestIdx = 0;
        for (let i = 0; i < einkColors.length; i++) {
            const ec = einkColors[i];
            const dist = Math.pow(r-ec[0],2) + Math.pow(g-ec[1],2) + Math.pow(b-ec[2],2);
            if (dist < minDist) {
                minDist = dist;
                closestIdx = i;
            }
        }
        return closestIdx;
    }
    
    const imageData = ctx.getImageData(x, y, width, height);
    const data = imageData.data;
    
    // Floyd-Steinberg dithering
    for (let py = 0; py < height; py++) {
        for (let px = 0; px < width; px++) {
            const idx = (py * width + px) * 4;
            let r = data[idx];
            let g = data[idx + 1];
            let b = data[idx + 2];
            
            // Find closest e-ink color
            const closestIdx = findClosestColorIdx(r, g, b);
            const targetColor = einkColors[closestIdx];
            
            // Calculate error
            const errorR = r - targetColor[0];
            const errorG = g - targetColor[1];
            const errorB = b - targetColor[2];
            
            // Set pixel to target color
            data[idx] = targetColor[0];
            data[idx + 1] = targetColor[1];
            data[idx + 2] = targetColor[2];
            
            // Distribute error to neighboring pixels (Floyd-Steinberg)
            if (px < width - 1) {
                // Right
                const rightIdx = idx + 4;
                data[rightIdx] = Math.max(0, Math.min(255, data[rightIdx] + errorR * 7/16));
                data[rightIdx + 1] = Math.max(0, Math.min(255, data[rightIdx + 1] + errorG * 7/16));
                data[rightIdx + 2] = Math.max(0, Math.min(255, data[rightIdx + 2] + errorB * 7/16));
            }
            if (py < height - 1) {
                // Bottom
                const bottomIdx = idx + width * 4;
                data[bottomIdx] = Math.max(0, Math.min(255, data[bottomIdx] + errorR * 5/16));
                data[bottomIdx + 1] = Math.max(0, Math.min(255, data[bottomIdx + 1] + errorG * 5/16));
                data[bottomIdx + 2] = Math.max(0, Math.min(255, data[bottomIdx + 2] + errorB * 5/16));
                
                if (px > 0) {
                    // Bottom-left
                    const bottomLeftIdx = bottomIdx - 4;
                    data[bottomLeftIdx] = Math.max(0, Math.min(255, data[bottomLeftIdx] + errorR * 3/16));
                    data[bottomLeftIdx + 1] = Math.max(0, Math.min(255, data[bottomLeftIdx + 1] + errorG * 3/16));
                    data[bottomLeftIdx + 2] = Math.max(0, Math.min(255, data[bottomLeftIdx + 2] + errorB * 3/16));
                }
                if (px < width - 1) {
                    // Bottom-right
                    const bottomRightIdx = bottomIdx + 4;
                    data[bottomRightIdx] = Math.max(0, Math.min(255, data[bottomRightIdx] + errorR * 1/16));
                    data[bottomRightIdx + 1] = Math.max(0, Math.min(255, data[bottomRightIdx + 1] + errorG * 1/16));
                    data[bottomRightIdx + 2] = Math.max(0, Math.min(255, data[bottomRightIdx + 2] + errorB * 1/16));
                }
            }
        }
    }
    
    ctx.putImageData(imageData, x, y);
}

function startDraw(e) {
    e.preventDefault();
    const coords = getCanvasCoordinates(e);
    const tool = getCurrentTool();
    
    if (tool === 'text') {
        const text = document.getElementById('canvasTextInput').value.trim();
        if (text) {
            saveCanvasState();
            ctx.fillStyle = getDrawColor();
            ctx.font = document.getElementById('textFontSize').value + 'px Arial';
            ctx.fillText(text, coords.x, coords.y);
        }
        return;
    }
    
    if (tool === 'fill') {
        saveCanvasState();
        floodFill(Math.floor(coords.x), Math.floor(coords.y), getDrawColor());
        return;
    }
    
    isDrawing = true;
    startX = lastX = coords.x;
    startY = lastY = coords.y;
    
    if (tool === 'rectangle' || tool === 'circle' || tool === 'line') {
        saveCanvasState();
    }
}

let previewCanvas = null;
let previewCtx = null;

function draw(e) {
    if (!isDrawing) return;
    e.preventDefault();
    const coords = getCanvasCoordinates(e);
    const tool = getCurrentTool();
    
    if (tool === 'brush' || tool === 'eraser') {
        const x = coords.x;
        const y = coords.y;
        ctx.strokeStyle = tool === 'eraser' ? '#FFFFFF' : getDrawColor();
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(x, y);
        ctx.stroke();
        lastX = x;
        lastY = y;
        } else if (tool === 'rectangle' || tool === 'circle' || tool === 'line') {
        // Restore last saved state and draw preview
        if (historyIndex >= 0) {
            ctx.putImageData(canvasHistory[historyIndex], 0, 0);
        }
        
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        if (tool === 'rectangle') {
            const width = coords.x - startX;
            const height = coords.y - startY;
            // Fill first, then stroke
            ctx.fillStyle = getFillColor();
            ctx.fillRect(startX, startY, width, height);
            ctx.strokeStyle = getOutlineColor();
            ctx.strokeRect(startX, startY, width, height);
        } else if (tool === 'circle') {
            const radius = Math.sqrt(Math.pow(coords.x - startX, 2) + Math.pow(coords.y - startY, 2));
            ctx.arc(startX, startY, radius, 0, Math.PI * 2);
            // Fill first, then stroke
            ctx.fillStyle = getFillColor();
            ctx.fill();
            ctx.strokeStyle = getOutlineColor();
            ctx.stroke();
        } else if (tool === 'line') {
            ctx.strokeStyle = getDrawColor();
            ctx.moveTo(startX, startY);
            ctx.lineTo(coords.x, coords.y);
            ctx.stroke();
        }
    }
}

function stopDraw() {
    if (!isDrawing) return;
    isDrawing = false;
    
    const tool = getCurrentTool();
    if (tool === 'brush' || tool === 'eraser') {
        saveCanvasState();
    }
    // Rectangle, circle, and line already saved state in startDraw
}

function undoCanvas() {
    restoreCanvasState();
}

// Update tool options visibility
document.getElementById('drawTool').addEventListener('change', function() {
    const tool = this.value;
    const textOptions = document.getElementById('textToolOptions');
    const textInput = document.getElementById('textInputContainer');
    const fillColorContainer = document.getElementById('fillColorContainer');
    const outlineColorContainer = document.getElementById('outlineColorContainer');
    const colorLabel = document.getElementById('colorLabel');
    
    // Show/hide text options
    if (tool === 'text') {
        textOptions.style.display = 'block';
        textInput.style.display = 'block';
    } else {
        textOptions.style.display = 'none';
        textInput.style.display = 'none';
    }
    
    // Show/hide fill and outline for shapes
    if (tool === 'rectangle' || tool === 'circle') {
        fillColorContainer.style.display = 'block';
        outlineColorContainer.style.display = 'block';
        colorLabel.textContent = 'Colour:';
    } else {
        fillColorContainer.style.display = 'none';
        outlineColorContainer.style.display = 'none';
        colorLabel.textContent = 'Colour:';
    }
});

function clearCanvas() {
    saveCanvasState();
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    showStatus('canvasStatus', 'Canvas cleared', false);
}

function loadImageToCanvas() {
    document.getElementById('imageFileInput').click();
}

function handleImageFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    if (!file.type.startsWith('image/')) {
        showStatus('canvasStatus', 'Error: Please select an image file', true);
        return;
    }
    
    const reader = new FileReader();
    reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
            saveCanvasState();
            
            // Calculate scaling to fit canvas while maintaining aspect ratio
            const canvasAspect = canvas.width / canvas.height;
            const imgAspect = img.width / img.height;
            
            let drawWidth, drawHeight, drawX, drawY;
            
            if (imgAspect > canvasAspect) {
                // Image is wider - fit to width
                drawWidth = canvas.width;
                drawHeight = canvas.width / imgAspect;
                drawX = 0;
                drawY = (canvas.height - drawHeight) / 2;
            } else {
                // Image is taller - fit to height
                drawWidth = canvas.height * imgAspect;
                drawHeight = canvas.height;
                drawX = (canvas.width - drawWidth) / 2;
                drawY = 0;
            }
            
            // Clear canvas and draw image centered
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
            
            // Posterize image to match e-ink colors
            posterizeImage(drawX, drawY, drawWidth, drawHeight);
            
            showStatus('canvasStatus', `Image loaded and posterized: ${img.width}x${img.height} (scaled to fit ${Math.round(drawWidth)}x${Math.round(drawHeight)})`, false);
        };
        img.onerror = function() {
            showStatus('canvasStatus', 'Error: Failed to load image', true);
        };
        img.src = e.target.result;
    };
    reader.onerror = function() {
        showStatus('canvasStatus', 'Error: Failed to read file', true);
    };
    reader.readAsDataURL(file);
    
    // Reset file input so same file can be selected again
    event.target.value = '';
}

canvas.addEventListener('mousedown', startDraw);
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('mouseup', stopDraw);
canvas.addEventListener('mouseleave', stopDraw);
canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDraw(e); });
canvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e); });
canvas.addEventListener('touchend', (e) => { e.preventDefault(); stopDraw(); });

clearCanvas();

// Auto-reconnect functionality
function scheduleReconnect() {
    if (reconnectTimeoutId) {
        clearTimeout(reconnectTimeoutId);
    }
    
    reconnectAttempts++;
    const delay = Math.min(INITIAL_RECONNECT_DELAY * Math.pow(2, reconnectAttempts - 1), 30000); // Exponential backoff, max 30s
    
    updateConnectionStatus('reconnecting', `Reconnecting in ${(delay/1000).toFixed(1)}s... (attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);
    
    reconnectTimeoutId = setTimeout(function() {
        console.log(`Auto-reconnect attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS}`);
        connectMQTT();
    }, delay);
}

function cancelReconnect() {
    if (reconnectTimeoutId) {
        clearTimeout(reconnectTimeoutId);
        reconnectTimeoutId = null;
    }
    reconnectAttempts = 0;
}

// Collapsible sections
function toggleSection(h2Element) {
    const section = h2Element.closest('.section');
    const content = section.querySelector('.section-content');
    if (!content) return;
    
    const isCollapsed = h2Element.classList.contains('collapsed');
    
    if (isCollapsed) {
        h2Element.classList.remove('collapsed');
        content.classList.remove('collapsed');
        localStorage.setItem('section_' + content.id, 'expanded');
    } else {
        h2Element.classList.add('collapsed');
        content.classList.add('collapsed');
        localStorage.setItem('section_' + content.id, 'collapsed');
    }
}

// Restore section states on page load (default to collapsed, except Authentication)
function restoreSectionStates() {
    document.querySelectorAll('.section-content').forEach(function(content) {
        const state = localStorage.getItem('section_' + content.id);
        const h2 = content.previousElementSibling;
        // Keep Authentication section open by default (it's required)
        if (content.id === 'section-auth') {
            // Only collapse if explicitly saved as collapsed
            if (state === 'collapsed' && h2) {
                h2.classList.add('collapsed');
                content.classList.add('collapsed');
            }
        } else {
            // Default to collapsed for all other sections if no saved state
            if (!state || state === 'collapsed') {
                if (h2) {
                    h2.classList.add('collapsed');
                    content.classList.add('collapsed');
                }
            }
        }
    });
}

// Keyboard shortcuts
function setupKeyboardShortcuts() {
    document.addEventListener('keydown', function(e) {
        // Ctrl/Cmd + Enter to send text display
        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
            const textInput = document.getElementById('textInput');
            if (textInput && document.activeElement === textInput) {
                e.preventDefault();
                const textDisplayBtn = document.getElementById('textDisplayBtn');
                if (textDisplayBtn && !textDisplayBtn.disabled) {
                    sendTextDisplay();
                }
            }
        }
        
        // Ctrl/Cmd + K to focus search (if we add search later)
        if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
            e.preventDefault();
            // Future: focus search input
        }
        
        // Esc to close modals (if we add modals later)
        if (e.key === 'Escape') {
            // Future: close any open modals
        }
    });
}

// Load password on page load (after all functions are defined)
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
        loadPassword();
        restoreSectionStates();
        setupKeyboardShortcuts();
        
        // Load auto-reconnect preference
        const autoReconnectPref = localStorage.getItem('autoReconnectEnabled');
        if (autoReconnectPref !== null) {
            autoReconnectEnabled = autoReconnectPref === 'true';
            const checkbox = document.getElementById('autoReconnect');
            if (checkbox) {
                checkbox.checked = autoReconnectEnabled;
            }
        }
        
        // Setup auto-reconnect checkbox handler
        const autoReconnectCheckbox = document.getElementById('autoReconnect');
        if (autoReconnectCheckbox) {
            autoReconnectCheckbox.addEventListener('change', function() {
                autoReconnectEnabled = this.checked;
                localStorage.setItem('autoReconnectEnabled', String(autoReconnectEnabled));
                if (!autoReconnectEnabled) {
                    cancelReconnect();
                }
            });
        }
    });
} else {
    // DOM already loaded
    loadPassword();
    restoreSectionStates();
    setupKeyboardShortcuts();
    
    // Load auto-reconnect preference
    const autoReconnectPref = localStorage.getItem('autoReconnectEnabled');
    if (autoReconnectPref !== null) {
        autoReconnectEnabled = autoReconnectPref === 'true';
        const checkbox = document.getElementById('autoReconnect');
        if (checkbox) {
            checkbox.checked = autoReconnectEnabled;
        }
    }
    
    // Setup auto-reconnect checkbox handler
    const autoReconnectCheckbox = document.getElementById('autoReconnect');
    if (autoReconnectCheckbox) {
        autoReconnectCheckbox.addEventListener('change', function() {
            autoReconnectEnabled = this.checked;
            localStorage.setItem('autoReconnectEnabled', String(autoReconnectEnabled));
            if (!autoReconnectEnabled) {
                cancelReconnect();
            }
        });
    }
}
</script>
</body>
</html>
