"""
PlatformIO pre-build script to generate self-signed certificate and create header file.

This script:
1. Generates a self-signed certificate if it doesn't exist or is older than 30 days
2. Creates a header file with the certificate and key embedded as strings
3. Can be used with PsychicHttp or other HTTPS libraries
"""

import os
import subprocess
import sys
from datetime import datetime, timedelta

def generate_cert_header(source, target, env):
    """Generate certificate and create header file if needed."""
    
    project_dir = env.subst("$PROJECT_DIR")
    cert_dir = os.path.join(project_dir, "certificates")
    cert_file = os.path.join(cert_dir, "server_cert.pem")
    key_file = os.path.join(cert_dir, "server_key.pem")
    header_file = os.path.join(project_dir, "src", "certificates.h")
    
    # Create certificates directory if it doesn't exist
    os.makedirs(cert_dir, exist_ok=True)
    
    # Check if certificates exist and are valid
    cert_exists = os.path.exists(cert_file) and os.path.exists(key_file)
    header_exists = os.path.exists(header_file)
    
    if cert_exists:
        # Verify certificate files are not empty and are valid PEM format
        try:
            with open(cert_file, 'r') as f:
                cert_content = f.read().strip()
            with open(key_file, 'r') as f:
                key_content = f.read().strip()
            
            # Check if files contain valid PEM markers
            if "-----BEGIN CERTIFICATE-----" in cert_content and "-----END CERTIFICATE-----" in cert_content:
                if "-----BEGIN" in key_content and "-----END" in key_content:
                    # Check if header file exists and is newer than certificates
                    if header_exists:
                        header_mtime = os.path.getmtime(header_file)
                        cert_mtime = os.path.getmtime(cert_file)
                    if header_mtime >= cert_mtime:
                        # Header is up to date, skip regeneration
                        print("Certificate and header file are up to date, skipping generation.")
                        return True
                    else:
                        # Header is older than certificate, regenerate
                        print("Header file is older than certificate, regenerating...")
                        regenerate_cert = False  # Don't regenerate cert, just header
                    
                    # Certificates exist and are valid, just need to regenerate header
                    print("Valid certificates found, generating header file...")
                    regenerate_cert = False
                else:
                    print("Key file appears invalid, regenerating certificates...")
                    regenerate_cert = True
            else:
                print("Certificate file appears invalid, regenerating...")
                regenerate_cert = True
        except IOError as e:
            print(f"Error reading certificate files: {e}, regenerating...")
            regenerate_cert = True
    else:
        print("Certificate files not found, generating...")
        regenerate_cert = True
    
    # Generate certificates if needed
    if regenerate_cert:
        print("Generating self-signed certificate...")
        try:
            # Generate private key (2048-bit RSA)
            subprocess.run([
                "openssl", "genrsa", "-out", key_file, "2048"
            ], check=True, capture_output=True)
            
            # Generate self-signed certificate (valid for 10 years)
            subprocess.run([
                "openssl", "req", "-new", "-x509", "-key", key_file,
                "-out", cert_file, "-days", "3650",
                "-subj", "/C=US/ST=State/L=City/O=ESP32-P4/CN=esp32.local"
            ], check=True, capture_output=True)
            
            print("Certificate generated successfully!")
        except subprocess.CalledProcessError as e:
            print(f"ERROR: Failed to generate certificate: {e}")
            print("Make sure OpenSSL is installed and available in PATH")
            return False
        except FileNotFoundError:
            print("ERROR: OpenSSL not found. Please install OpenSSL.")
            print("On Ubuntu/Debian: sudo apt-get install openssl")
            print("On macOS: brew install openssl")
            return False
    
    # Read certificate and key files (either newly generated or existing)
    try:
        with open(cert_file, 'r') as f:
            cert_content = f.read().strip()
        with open(key_file, 'r') as f:
            key_content = f.read().strip()
    except IOError as e:
        print(f"ERROR: Failed to read certificate files: {e}")
        return False
    
    # Generate header file
    header_content = f"""// HTTPS Certificate and Private Key
// 
// Auto-generated by scripts/generate_cert_header.py
// Certificate is valid for 10 years and regenerated if older than 30 days
// 
// NOTE: For production, use a proper CA-signed certificate. Self-signed certificates
// will trigger browser security warnings (users can click "Advanced" -> "Proceed").
//
// The certificate and key are embedded as strings for use with HTTPS libraries.

#ifndef CERTIFICATES_H
#define CERTIFICATES_H

// Self-signed certificate (PEM format)
const char* server_cert = R"EOF(
{cert_content}
)EOF";

// Private key (PEM format) - KEEP SECRET!
const char* server_key = R"EOF(
{key_content}
)EOF";

#endif // CERTIFICATES_H
"""
    
    # Write header file
    try:
        with open(header_file, 'w') as f:
            f.write(header_content)
        print(f"Certificate header generated: {header_file}")
    except IOError as e:
        print(f"ERROR: Failed to write header file: {e}")
        sys.exit(1)

# Register the function to run before building
# Use "buildprog" instead of file-specific target to ensure it runs every build
# Also ensure it runs even if there are errors - always generate the file
def ensure_cert_header(source, target, env):
    """Wrapper to ensure certificate header is always generated."""
    print("=" * 60)
    print("Running generate_cert_header pre-build script...")
    print("=" * 60)
    
    project_dir = env.subst("$PROJECT_DIR")
    header_file = os.path.join(project_dir, "src", "certificates.h")
    
    # Always ensure file exists - create stub first, then try to generate proper one
    stub_content = """// Stub certificates.h - will be replaced if generation succeeds
#ifndef CERTIFICATES_H
#define CERTIFICATES_H
const char server_cert[] = "-----BEGIN CERTIFICATE-----\\n-----END CERTIFICATE-----\\n";
const char server_key[] = "-----BEGIN PRIVATE KEY-----\\n-----END PRIVATE KEY-----\\n";
#endif
"""
    
    # Create stub immediately so compilation can proceed
    if not os.path.exists(header_file):
        try:
            with open(header_file, 'w') as f:
                f.write(stub_content)
            print(f"✓ Created initial stub header: {header_file}")
        except Exception as e:
            print(f"ERROR: Failed to create stub header: {e}")
    
    # Now try to generate proper certificate
    try:
        result = generate_cert_header(source, target, env)
        if result:
            print("✓ Certificate header generated successfully")
        else:
            print("WARNING: generate_cert_header returned False, keeping stub...")
    except Exception as e:
        print(f"ERROR in generate_cert_header: {e}")
        import traceback
        traceback.print_exc()
        print("Keeping stub header for compilation...")
    print("=" * 60)

# Register the function to run before building (only when called from PlatformIO)
# Use "buildprog" instead of file-specific target to ensure it runs every build
try:
    Import("env")
    env.AddPreAction("buildprog", ensure_cert_header)
except:
    # Called directly (for testing) - run the function manually
    class FakeEnv:
        def subst(self, s):
            return os.path.dirname(os.path.dirname(__file__))
    fake_env = FakeEnv()
    ensure_cert_header(None, None, fake_env)

